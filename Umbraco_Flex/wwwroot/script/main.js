

try {
	!function (e) { var t = {}; function s(a) { if (t[a]) return t[a].exports; var i = t[a] = { i: a, l: !1, exports: {} }; return e[a].call(i.exports, i, i.exports, s), i.l = !0, i.exports } s.m = e, s.c = t, s.d = function (e, t, a) { s.o(e, t) || Object.defineProperty(e, t, { enumerable: !0, get: a }) }, s.r = function (e) { "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e, "__esModule", { value: !0 }) }, s.t = function (e, t) { if (1 & t && (e = s(e)), 8 & t) return e; if (4 & t && "object" == typeof e && e && e.__esModule) return e; var a = Object.create(null); if (s.r(a), Object.defineProperty(a, "default", { enumerable: !0, value: e }), 2 & t && "string" != typeof e) for (var i in e) s.d(a, i, function (t) { return e[t] }.bind(null, i)); return a }, s.n = function (e) { var t = e && e.__esModule ? function () { return e.default } : function () { return e }; return s.d(t, "a", t), t }, s.o = function (e, t) { return Object.prototype.hasOwnProperty.call(e, t) }, s.p = "", s(s.s = 0) }([function (e, t, s) { s(1), e.exports = s(2) }, function (e, t, s) { "use strict"; function a(e) { return (a = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) { return typeof e } : function (e) { return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e })(e) } function i(e, t) { for (var s = 0; s < t.length; s++) { var i = t[s]; i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, (n = i.key, r = void 0, r = function (e, t) { if ("object" !== a(e) || null === e) return e; var s = e[Symbol.toPrimitive]; if (void 0 !== s) { var i = s.call(e, t || "default"); if ("object" !== a(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value.") } return ("string" === t ? String : Number)(e) }(n, "string"), "symbol" === a(r) ? r : String(r)), i) } var n, r } s.r(t); var n = function () { function e() { var t = this; !function (e, t) { if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function") }(this, e), this.header = document.querySelector(".header"), this.search_btn = !!this.header && this.header.querySelector(".header__link-search"), this.hamburger = !!this.header && this.header.querySelector(".header__hamburger"), !this.header || this.submenu(), !this.search_btn || this.search_btn.addEventListener("click", (function (e) { return t.toggleSearch(e) })), !this.hamburger || this.hamburger.querySelector("button").addEventListener("click", (function (e) { return t.navToggle(e) })) } var t, s, a; return t = e, (s = [{ key: "navToggle", value: function (e) { e.target.classList.toggle("active"), this.header.querySelector(".collapse").classList.toggle("active"), this.search_btn.classList.contains("active") && (this.search_btn.classList.remove("active"), this.header.querySelector(".header__content-search").classList.remove("active")) } }, { key: "toggleSearch", value: function (e) { e.preventDefault(), e.target.classList.toggle("active"), this.header.querySelector(".header__content-search").classList.toggle("active"), this.hamburger.querySelector("button").classList.contains("active") && (this.hamburger.querySelector("button").classList.remove("active"), this.header.querySelector(".collapse").classList.remove("active")) } }, { key: "submenu", value: function () { document.addEventListener("DOMContentLoaded", (function () { document.querySelectorAll(".navbar .dropdown").forEach((function (e) { e.addEventListener("hidden.bs.dropdown", (function () { this.querySelectorAll(".submenu").forEach((function (e) { e.style.display = "none" })) })) })), document.querySelectorAll(".dropdown-menu a").forEach((function (e) { e.addEventListener("click", (function (e) { var t = this.nextElementSibling; t && t.classList.contains("submenu") && (e.preventDefault(), "block" == t.style.display ? t.style.display = "none" : t.style.display = "block") })) })) })) } }]) && i(t.prototype, s), a && i(t, a), Object.defineProperty(t, "prototype", { writable: !1 }), e }(); function r(e) { return null !== e && "object" == typeof e && "constructor" in e && e.constructor === Object } function l(e, t) { void 0 === e && (e = {}), void 0 === t && (t = {}), Object.keys(t).forEach((function (s) { void 0 === e[s] ? e[s] = t[s] : r(t[s]) && r(e[s]) && Object.keys(t[s]).length > 0 && l(e[s], t[s]) })) } var o = "undefined" != typeof document ? document : {}, d = { body: {}, addEventListener: function () { }, removeEventListener: function () { }, activeElement: { blur: function () { }, nodeName: "" }, querySelector: function () { return null }, querySelectorAll: function () { return [] }, getElementById: function () { return null }, createEvent: function () { return { initEvent: function () { } } }, createElement: function () { return { children: [], childNodes: [], style: {}, setAttribute: function () { }, getElementsByTagName: function () { return [] } } }, createElementNS: function () { return {} }, importNode: function () { return null }, location: { hash: "", host: "", hostname: "", href: "", origin: "", pathname: "", protocol: "", search: "" } }; l(o, d); var c = "undefined" != typeof window ? window : {}; l(c, { document: d, navigator: { userAgent: "" }, location: { hash: "", host: "", hostname: "", href: "", origin: "", pathname: "", protocol: "", search: "" }, history: { replaceState: function () { }, pushState: function () { }, go: function () { }, back: function () { } }, CustomEvent: function () { return this }, addEventListener: function () { }, removeEventListener: function () { }, getComputedStyle: function () { return { getPropertyValue: function () { return "" } } }, Image: function () { }, Date: function () { }, screen: {}, setTimeout: function () { }, clearTimeout: function () { }, matchMedia: function () { return {} } }); class p { constructor(e) { const t = this; for (let s = 0; s < e.length; s += 1)t[s] = e[s]; return t.length = e.length, this } } function u(e, t) { const s = []; let a = 0; if (e && !t && e instanceof p) return e; if (e) if ("string" == typeof e) { let i, n; const r = e.trim(); if (r.indexOf("<") >= 0 && r.indexOf(">") >= 0) { let e = "div"; for (0 === r.indexOf("<li") && (e = "ul"), 0 === r.indexOf("<tr") && (e = "tbody"), 0 !== r.indexOf("<td") && 0 !== r.indexOf("<th") || (e = "tr"), 0 === r.indexOf("<tbody") && (e = "table"), 0 === r.indexOf("<option") && (e = "select"), n = o.createElement(e), n.innerHTML = r, a = 0; a < n.childNodes.length; a += 1)s.push(n.childNodes[a]) } else for (i = t || "#" !== e[0] || e.match(/[ .<>:~]/) ? (t || o).querySelectorAll(e.trim()) : [o.getElementById(e.trim().split("#")[1])], a = 0; a < i.length; a += 1)i[a] && s.push(i[a]) } else if (e.nodeType || e === c || e === o) s.push(e); else if (e.length > 0 && e[0].nodeType) for (a = 0; a < e.length; a += 1)s.push(e[a]); return new p(s) } function h(e) { const t = []; for (let s = 0; s < e.length; s += 1)-1 === t.indexOf(e[s]) && t.push(e[s]); return t } u.fn = p.prototype, u.Class = p, u.Dom7 = p; "resize scroll".split(" "); const m = { addClass: function (e) { if (void 0 === e) return this; const t = e.split(" "); for (let e = 0; e < t.length; e += 1)for (let s = 0; s < this.length; s += 1)void 0 !== this[s] && void 0 !== this[s].classList && this[s].classList.add(t[e]); return this }, removeClass: function (e) { const t = e.split(" "); for (let e = 0; e < t.length; e += 1)for (let s = 0; s < this.length; s += 1)void 0 !== this[s] && void 0 !== this[s].classList && this[s].classList.remove(t[e]); return this }, hasClass: function (e) { return !!this[0] && this[0].classList.contains(e) }, toggleClass: function (e) { const t = e.split(" "); for (let e = 0; e < t.length; e += 1)for (let s = 0; s < this.length; s += 1)void 0 !== this[s] && void 0 !== this[s].classList && this[s].classList.toggle(t[e]); return this }, attr: function (e, t) { if (1 === arguments.length && "string" == typeof e) return this[0] ? this[0].getAttribute(e) : void 0; for (let s = 0; s < this.length; s += 1)if (2 === arguments.length) this[s].setAttribute(e, t); else for (const t in e) this[s][t] = e[t], this[s].setAttribute(t, e[t]); return this }, removeAttr: function (e) { for (let t = 0; t < this.length; t += 1)this[t].removeAttribute(e); return this }, data: function (e, t) { let s; if (void 0 !== t) { for (let a = 0; a < this.length; a += 1)s = this[a], s.dom7ElementDataStorage || (s.dom7ElementDataStorage = {}), s.dom7ElementDataStorage[e] = t; return this } if (s = this[0], s) { if (s.dom7ElementDataStorage && e in s.dom7ElementDataStorage) return s.dom7ElementDataStorage[e]; const t = s.getAttribute("data-" + e); return t || void 0 } }, transform: function (e) { for (let t = 0; t < this.length; t += 1) { const s = this[t].style; s.webkitTransform = e, s.transform = e } return this }, transition: function (e) { "string" != typeof e && (e += "ms"); for (let t = 0; t < this.length; t += 1) { const s = this[t].style; s.webkitTransitionDuration = e, s.transitionDuration = e } return this }, on: function (...e) { let [t, s, a, i] = e; function n(e) { const t = e.target; if (!t) return; const i = e.target.dom7EventData || []; if (i.indexOf(e) < 0 && i.unshift(e), u(t).is(s)) a.apply(t, i); else { const e = u(t).parents(); for (let t = 0; t < e.length; t += 1)u(e[t]).is(s) && a.apply(e[t], i) } } function r(e) { const t = e && e.target && e.target.dom7EventData || []; t.indexOf(e) < 0 && t.unshift(e), a.apply(this, t) } "function" == typeof e[1] && ([t, a, i] = e, s = void 0), i || (i = !1); const l = t.split(" "); let o; for (let e = 0; e < this.length; e += 1) { const t = this[e]; if (s) for (o = 0; o < l.length; o += 1) { const e = l[o]; t.dom7LiveListeners || (t.dom7LiveListeners = {}), t.dom7LiveListeners[e] || (t.dom7LiveListeners[e] = []), t.dom7LiveListeners[e].push({ listener: a, proxyListener: n }), t.addEventListener(e, n, i) } else for (o = 0; o < l.length; o += 1) { const e = l[o]; t.dom7Listeners || (t.dom7Listeners = {}), t.dom7Listeners[e] || (t.dom7Listeners[e] = []), t.dom7Listeners[e].push({ listener: a, proxyListener: r }), t.addEventListener(e, r, i) } } return this }, off: function (...e) { let [t, s, a, i] = e; "function" == typeof e[1] && ([t, a, i] = e, s = void 0), i || (i = !1); const n = t.split(" "); for (let e = 0; e < n.length; e += 1) { const t = n[e]; for (let e = 0; e < this.length; e += 1) { const n = this[e]; let r; if (!s && n.dom7Listeners ? r = n.dom7Listeners[t] : s && n.dom7LiveListeners && (r = n.dom7LiveListeners[t]), r && r.length) for (let e = r.length - 1; e >= 0; e -= 1) { const s = r[e]; a && s.listener === a || a && s.listener && s.listener.dom7proxy && s.listener.dom7proxy === a ? (n.removeEventListener(t, s.proxyListener, i), r.splice(e, 1)) : a || (n.removeEventListener(t, s.proxyListener, i), r.splice(e, 1)) } } } return this }, trigger: function (...e) { const t = e[0].split(" "), s = e[1]; for (let a = 0; a < t.length; a += 1) { const i = t[a]; for (let t = 0; t < this.length; t += 1) { const a = this[t]; let n; try { n = new c.CustomEvent(i, { detail: s, bubbles: !0, cancelable: !0 }) } catch (e) { n = o.createEvent("Event"), n.initEvent(i, !0, !0), n.detail = s } a.dom7EventData = e.filter((e, t) => t > 0), a.dispatchEvent(n), a.dom7EventData = [], delete a.dom7EventData } } return this }, transitionEnd: function (e) { const t = ["webkitTransitionEnd", "transitionend"], s = this; let a; function i(n) { if (n.target === this) for (e.call(this, n), a = 0; a < t.length; a += 1)s.off(t[a], i) } if (e) for (a = 0; a < t.length; a += 1)s.on(t[a], i); return this }, outerWidth: function (e) { if (this.length > 0) { if (e) { const e = this.styles(); return this[0].offsetWidth + parseFloat(e.getPropertyValue("margin-right")) + parseFloat(e.getPropertyValue("margin-left")) } return this[0].offsetWidth } return null }, outerHeight: function (e) { if (this.length > 0) { if (e) { const e = this.styles(); return this[0].offsetHeight + parseFloat(e.getPropertyValue("margin-top")) + parseFloat(e.getPropertyValue("margin-bottom")) } return this[0].offsetHeight } return null }, offset: function () { if (this.length > 0) { const e = this[0], t = e.getBoundingClientRect(), s = o.body, a = e.clientTop || s.clientTop || 0, i = e.clientLeft || s.clientLeft || 0, n = e === c ? c.scrollY : e.scrollTop, r = e === c ? c.scrollX : e.scrollLeft; return { top: t.top + n - a, left: t.left + r - i } } return null }, css: function (e, t) { let s; if (1 === arguments.length) { if ("string" != typeof e) { for (s = 0; s < this.length; s += 1)for (let t in e) this[s].style[t] = e[t]; return this } if (this[0]) return c.getComputedStyle(this[0], null).getPropertyValue(e) } if (2 === arguments.length && "string" == typeof e) { for (s = 0; s < this.length; s += 1)this[s].style[e] = t; return this } return this }, each: function (e) { if (!e) return this; for (let t = 0; t < this.length; t += 1)if (!1 === e.call(this[t], t, this[t])) return this; return this }, html: function (e) { if (void 0 === e) return this[0] ? this[0].innerHTML : void 0; for (let t = 0; t < this.length; t += 1)this[t].innerHTML = e; return this }, text: function (e) { if (void 0 === e) return this[0] ? this[0].textContent.trim() : null; for (let t = 0; t < this.length; t += 1)this[t].textContent = e; return this }, is: function (e) { const t = this[0]; let s, a; if (!t || void 0 === e) return !1; if ("string" == typeof e) { if (t.matches) return t.matches(e); if (t.webkitMatchesSelector) return t.webkitMatchesSelector(e); if (t.msMatchesSelector) return t.msMatchesSelector(e); for (s = u(e), a = 0; a < s.length; a += 1)if (s[a] === t) return !0; return !1 } if (e === o) return t === o; if (e === c) return t === c; if (e.nodeType || e instanceof p) { for (s = e.nodeType ? [e] : e, a = 0; a < s.length; a += 1)if (s[a] === t) return !0; return !1 } return !1 }, index: function () { let e, t = this[0]; if (t) { for (e = 0; null !== (t = t.previousSibling);)1 === t.nodeType && (e += 1); return e } }, eq: function (e) { if (void 0 === e) return this; const t = this.length; let s; return e > t - 1 ? new p([]) : e < 0 ? (s = t + e, new p(s < 0 ? [] : [this[s]])) : new p([this[e]]) }, append: function (...e) { let t; for (let s = 0; s < e.length; s += 1) { t = e[s]; for (let e = 0; e < this.length; e += 1)if ("string" == typeof t) { const s = o.createElement("div"); for (s.innerHTML = t; s.firstChild;)this[e].appendChild(s.firstChild) } else if (t instanceof p) for (let s = 0; s < t.length; s += 1)this[e].appendChild(t[s]); else this[e].appendChild(t) } return this }, prepend: function (e) { let t, s; for (t = 0; t < this.length; t += 1)if ("string" == typeof e) { const a = o.createElement("div"); for (a.innerHTML = e, s = a.childNodes.length - 1; s >= 0; s -= 1)this[t].insertBefore(a.childNodes[s], this[t].childNodes[0]) } else if (e instanceof p) for (s = 0; s < e.length; s += 1)this[t].insertBefore(e[s], this[t].childNodes[0]); else this[t].insertBefore(e, this[t].childNodes[0]); return this }, next: function (e) { return this.length > 0 ? e ? this[0].nextElementSibling && u(this[0].nextElementSibling).is(e) ? new p([this[0].nextElementSibling]) : new p([]) : this[0].nextElementSibling ? new p([this[0].nextElementSibling]) : new p([]) : new p([]) }, nextAll: function (e) { const t = []; let s = this[0]; if (!s) return new p([]); for (; s.nextElementSibling;) { const a = s.nextElementSibling; e ? u(a).is(e) && t.push(a) : t.push(a), s = a } return new p(t) }, prev: function (e) { if (this.length > 0) { const t = this[0]; return e ? t.previousElementSibling && u(t.previousElementSibling).is(e) ? new p([t.previousElementSibling]) : new p([]) : t.previousElementSibling ? new p([t.previousElementSibling]) : new p([]) } return new p([]) }, prevAll: function (e) { const t = []; let s = this[0]; if (!s) return new p([]); for (; s.previousElementSibling;) { const a = s.previousElementSibling; e ? u(a).is(e) && t.push(a) : t.push(a), s = a } return new p(t) }, parent: function (e) { const t = []; for (let s = 0; s < this.length; s += 1)null !== this[s].parentNode && (e ? u(this[s].parentNode).is(e) && t.push(this[s].parentNode) : t.push(this[s].parentNode)); return u(h(t)) }, parents: function (e) { const t = []; for (let s = 0; s < this.length; s += 1) { let a = this[s].parentNode; for (; a;)e ? u(a).is(e) && t.push(a) : t.push(a), a = a.parentNode } return u(h(t)) }, closest: function (e) { let t = this; return void 0 === e ? new p([]) : (t.is(e) || (t = t.parents(e).eq(0)), t) }, find: function (e) { const t = []; for (let s = 0; s < this.length; s += 1) { const a = this[s].querySelectorAll(e); for (let e = 0; e < a.length; e += 1)t.push(a[e]) } return new p(t) }, children: function (e) { const t = []; for (let s = 0; s < this.length; s += 1) { const a = this[s].childNodes; for (let s = 0; s < a.length; s += 1)e ? 1 === a[s].nodeType && u(a[s]).is(e) && t.push(a[s]) : 1 === a[s].nodeType && t.push(a[s]) } return new p(h(t)) }, filter: function (e) { const t = [], s = this; for (let a = 0; a < s.length; a += 1)e.call(s[a], a, s[a]) && t.push(s[a]); return new p(t) }, remove: function () { for (let e = 0; e < this.length; e += 1)this[e].parentNode && this[e].parentNode.removeChild(this[e]); return this }, add: function (...e) { const t = this; let s, a; for (s = 0; s < e.length; s += 1) { const i = u(e[s]); for (a = 0; a < i.length; a += 1)t[t.length] = i[a], t.length += 1 } return t }, styles: function () { return this[0] ? c.getComputedStyle(this[0], null) : {} } }; Object.keys(m).forEach(e => { u.fn[e] = u.fn[e] || m[e] }); const f = { deleteProps(e) { const t = e; Object.keys(t).forEach(e => { try { t[e] = null } catch (e) { } try { delete t[e] } catch (e) { } }) }, nextTick: (e, t = 0) => setTimeout(e, t), now: () => Date.now(), getTranslate(e, t = "x") { let s, a, i; const n = c.getComputedStyle(e, null); return c.WebKitCSSMatrix ? (a = n.transform || n.webkitTransform, a.split(",").length > 6 && (a = a.split(", ").map(e => e.replace(",", ".")).join(", ")), i = new c.WebKitCSSMatrix("none" === a ? "" : a)) : (i = n.MozTransform || n.OTransform || n.MsTransform || n.msTransform || n.transform || n.getPropertyValue("transform").replace("translate(", "matrix(1, 0, 0, 1,"), s = i.toString().split(",")), "x" === t && (a = c.WebKitCSSMatrix ? i.m41 : 16 === s.length ? parseFloat(s[12]) : parseFloat(s[4])), "y" === t && (a = c.WebKitCSSMatrix ? i.m42 : 16 === s.length ? parseFloat(s[13]) : parseFloat(s[5])), a || 0 }, parseUrlQuery(e) { const t = {}; let s, a, i, n, r = e || c.location.href; if ("string" == typeof r && r.length) for (r = r.indexOf("?") > -1 ? r.replace(/\S*\?/, "") : "", a = r.split("&").filter(e => "" !== e), n = a.length, s = 0; s < n; s += 1)i = a[s].replace(/#\S+/g, "").split("="), t[decodeURIComponent(i[0])] = void 0 === i[1] ? void 0 : decodeURIComponent(i[1]) || ""; return t }, isObject: e => "object" == typeof e && null !== e && e.constructor && e.constructor === Object, extend(...e) { const t = Object(e[0]); for (let s = 1; s < e.length; s += 1) { const a = e[s]; if (null != a) { const e = Object.keys(Object(a)); for (let s = 0, i = e.length; s < i; s += 1) { const i = e[s], n = Object.getOwnPropertyDescriptor(a, i); void 0 !== n && n.enumerable && (f.isObject(t[i]) && f.isObject(a[i]) ? f.extend(t[i], a[i]) : !f.isObject(t[i]) && f.isObject(a[i]) ? (t[i] = {}, f.extend(t[i], a[i])) : t[i] = a[i]) } } } return t } }, g = { touch: !!("ontouchstart" in c || c.DocumentTouch && o instanceof c.DocumentTouch), pointerEvents: !!c.PointerEvent && "maxTouchPoints" in c.navigator && c.navigator.maxTouchPoints >= 0, observer: "MutationObserver" in c || "WebkitMutationObserver" in c, passiveListener: function () { let e = !1; try { const t = Object.defineProperty({}, "passive", { get() { e = !0 } }); c.addEventListener("testPassiveListener", null, t) } catch (e) { } return e }(), gestures: "ongesturestart" in c }; class v { constructor(e = {}) { const t = this; t.params = e, t.eventsListeners = {}, t.params && t.params.on && Object.keys(t.params.on).forEach(e => { t.on(e, t.params.on[e]) }) } on(e, t, s) { const a = this; if ("function" != typeof t) return a; const i = s ? "unshift" : "push"; return e.split(" ").forEach(e => { a.eventsListeners[e] || (a.eventsListeners[e] = []), a.eventsListeners[e][i](t) }), a } once(e, t, s) { const a = this; if ("function" != typeof t) return a; function i(...s) { a.off(e, i), i.f7proxy && delete i.f7proxy, t.apply(a, s) } return i.f7proxy = t, a.on(e, i, s) } off(e, t) { const s = this; return s.eventsListeners ? (e.split(" ").forEach(e => { void 0 === t ? s.eventsListeners[e] = [] : s.eventsListeners[e] && s.eventsListeners[e].length && s.eventsListeners[e].forEach((a, i) => { (a === t || a.f7proxy && a.f7proxy === t) && s.eventsListeners[e].splice(i, 1) }) }), s) : s } emit(...e) { const t = this; if (!t.eventsListeners) return t; let s, a, i; "string" == typeof e[0] || Array.isArray(e[0]) ? (s = e[0], a = e.slice(1, e.length), i = t) : (s = e[0].events, a = e[0].data, i = e[0].context || t); return (Array.isArray(s) ? s : s.split(" ")).forEach(e => { if (t.eventsListeners && t.eventsListeners[e]) { const s = []; t.eventsListeners[e].forEach(e => { s.push(e) }), s.forEach(e => { e.apply(i, a) }) } }), t } useModulesParams(e) { const t = this; t.modules && Object.keys(t.modules).forEach(s => { const a = t.modules[s]; a.params && f.extend(e, a.params) }) } useModules(e = {}) { const t = this; t.modules && Object.keys(t.modules).forEach(s => { const a = t.modules[s], i = e[s] || {}; a.instance && Object.keys(a.instance).forEach(e => { const s = a.instance[e]; t[e] = "function" == typeof s ? s.bind(t) : s }), a.on && t.on && Object.keys(a.on).forEach(e => { t.on(e, a.on[e]) }), a.create && a.create.bind(t)(i) }) } static set components(e) { this.use && this.use(e) } static installModule(e, ...t) { const s = this; s.prototype.modules || (s.prototype.modules = {}); const a = e.name || `${Object.keys(s.prototype.modules).length}_${f.now()}`; return s.prototype.modules[a] = e, e.proto && Object.keys(e.proto).forEach(t => { s.prototype[t] = e.proto[t] }), e.static && Object.keys(e.static).forEach(t => { s[t] = e.static[t] }), e.install && e.install.apply(s, t), s } static use(e, ...t) { const s = this; return Array.isArray(e) ? (e.forEach(e => s.installModule(e)), s) : s.installModule(e, ...t) } } var b = { updateSize: function () { const e = this; let t, s; const a = e.$el; t = void 0 !== e.params.width ? e.params.width : a[0].clientWidth, s = void 0 !== e.params.height ? e.params.height : a[0].clientHeight, 0 === t && e.isHorizontal() || 0 === s && e.isVertical() || (t = t - parseInt(a.css("padding-left"), 10) - parseInt(a.css("padding-right"), 10), s = s - parseInt(a.css("padding-top"), 10) - parseInt(a.css("padding-bottom"), 10), f.extend(e, { width: t, height: s, size: e.isHorizontal() ? t : s })) }, updateSlides: function () { const e = this, t = e.params, { $wrapperEl: s, size: a, rtlTranslate: i, wrongRTL: n } = e, r = e.virtual && t.virtual.enabled, l = r ? e.virtual.slides.length : e.slides.length, o = s.children("." + e.params.slideClass), d = r ? e.virtual.slides.length : o.length; let p = []; const u = [], h = []; function m(e) { return !t.cssMode || e !== o.length - 1 } let g = t.slidesOffsetBefore; "function" == typeof g && (g = t.slidesOffsetBefore.call(e)); let v = t.slidesOffsetAfter; "function" == typeof v && (v = t.slidesOffsetAfter.call(e)); const b = e.snapGrid.length, y = e.snapGrid.length; let w, x, E = t.spaceBetween, S = -g, T = 0, C = 0; if (void 0 === a) return; "string" == typeof E && E.indexOf("%") >= 0 && (E = parseFloat(E.replace("%", "")) / 100 * a), e.virtualSize = -E, i ? o.css({ marginLeft: "", marginTop: "" }) : o.css({ marginRight: "", marginBottom: "" }), t.slidesPerColumn > 1 && (w = Math.floor(d / t.slidesPerColumn) === d / e.params.slidesPerColumn ? d : Math.ceil(d / t.slidesPerColumn) * t.slidesPerColumn, "auto" !== t.slidesPerView && "row" === t.slidesPerColumnFill && (w = Math.max(w, t.slidesPerView * t.slidesPerColumn))); const M = t.slidesPerColumn, $ = w / M, k = Math.floor(d / t.slidesPerColumn); for (let s = 0; s < d; s += 1) { x = 0; const i = o.eq(s); if (t.slidesPerColumn > 1) { let a, n, r; if ("row" === t.slidesPerColumnFill && t.slidesPerGroup > 1) { const e = Math.floor(s / (t.slidesPerGroup * t.slidesPerColumn)), l = s - t.slidesPerColumn * t.slidesPerGroup * e, o = 0 === e ? t.slidesPerGroup : Math.min(Math.ceil((d - e * M * t.slidesPerGroup) / M), t.slidesPerGroup); r = Math.floor(l / o), n = l - r * o + e * t.slidesPerGroup, a = n + r * w / M, i.css({ "-webkit-box-ordinal-group": a, "-moz-box-ordinal-group": a, "-ms-flex-order": a, "-webkit-order": a, order: a }) } else "column" === t.slidesPerColumnFill ? (n = Math.floor(s / M), r = s - n * M, (n > k || n === k && r === M - 1) && (r += 1, r >= M && (r = 0, n += 1))) : (r = Math.floor(s / $), n = s - r * $); i.css("margin-" + (e.isHorizontal() ? "top" : "left"), 0 !== r && t.spaceBetween && t.spaceBetween + "px") } if ("none" !== i.css("display")) { if ("auto" === t.slidesPerView) { const s = c.getComputedStyle(i[0], null), a = i[0].style.transform, n = i[0].style.webkitTransform; if (a && (i[0].style.transform = "none"), n && (i[0].style.webkitTransform = "none"), t.roundLengths) x = e.isHorizontal() ? i.outerWidth(!0) : i.outerHeight(!0); else if (e.isHorizontal()) { const e = parseFloat(s.getPropertyValue("width")), t = parseFloat(s.getPropertyValue("padding-left")), a = parseFloat(s.getPropertyValue("padding-right")), i = parseFloat(s.getPropertyValue("margin-left")), n = parseFloat(s.getPropertyValue("margin-right")), r = s.getPropertyValue("box-sizing"); x = r && "border-box" === r ? e + i + n : e + t + a + i + n } else { const e = parseFloat(s.getPropertyValue("height")), t = parseFloat(s.getPropertyValue("padding-top")), a = parseFloat(s.getPropertyValue("padding-bottom")), i = parseFloat(s.getPropertyValue("margin-top")), n = parseFloat(s.getPropertyValue("margin-bottom")), r = s.getPropertyValue("box-sizing"); x = r && "border-box" === r ? e + i + n : e + t + a + i + n } a && (i[0].style.transform = a), n && (i[0].style.webkitTransform = n), t.roundLengths && (x = Math.floor(x)) } else x = (a - (t.slidesPerView - 1) * E) / t.slidesPerView, t.roundLengths && (x = Math.floor(x)), o[s] && (e.isHorizontal() ? o[s].style.width = x + "px" : o[s].style.height = x + "px"); o[s] && (o[s].swiperSlideSize = x), h.push(x), t.centeredSlides ? (S = S + x / 2 + T / 2 + E, 0 === T && 0 !== s && (S = S - a / 2 - E), 0 === s && (S = S - a / 2 - E), Math.abs(S) < .001 && (S = 0), t.roundLengths && (S = Math.floor(S)), C % t.slidesPerGroup == 0 && p.push(S), u.push(S)) : (t.roundLengths && (S = Math.floor(S)), (C - Math.min(e.params.slidesPerGroupSkip, C)) % e.params.slidesPerGroup == 0 && p.push(S), u.push(S), S = S + x + E), e.virtualSize += x + E, T = x, C += 1 } } let P; if (e.virtualSize = Math.max(e.virtualSize, a) + v, i && n && ("slide" === t.effect || "coverflow" === t.effect) && s.css({ width: e.virtualSize + t.spaceBetween + "px" }), t.setWrapperSize && (e.isHorizontal() ? s.css({ width: e.virtualSize + t.spaceBetween + "px" }) : s.css({ height: e.virtualSize + t.spaceBetween + "px" })), t.slidesPerColumn > 1 && (e.virtualSize = (x + t.spaceBetween) * w, e.virtualSize = Math.ceil(e.virtualSize / t.slidesPerColumn) - t.spaceBetween, e.isHorizontal() ? s.css({ width: e.virtualSize + t.spaceBetween + "px" }) : s.css({ height: e.virtualSize + t.spaceBetween + "px" }), t.centeredSlides)) { P = []; for (let s = 0; s < p.length; s += 1) { let a = p[s]; t.roundLengths && (a = Math.floor(a)), p[s] < e.virtualSize + p[0] && P.push(a) } p = P } if (!t.centeredSlides) { P = []; for (let s = 0; s < p.length; s += 1) { let i = p[s]; t.roundLengths && (i = Math.floor(i)), p[s] <= e.virtualSize - a && P.push(i) } p = P, Math.floor(e.virtualSize - a) - Math.floor(p[p.length - 1]) > 1 && p.push(e.virtualSize - a) } if (0 === p.length && (p = [0]), 0 !== t.spaceBetween && (e.isHorizontal() ? i ? o.filter(m).css({ marginLeft: E + "px" }) : o.filter(m).css({ marginRight: E + "px" }) : o.filter(m).css({ marginBottom: E + "px" })), t.centeredSlides && t.centeredSlidesBounds) { let e = 0; h.forEach(s => { e += s + (t.spaceBetween ? t.spaceBetween : 0) }), e -= t.spaceBetween; const s = e - a; p = p.map(e => e < 0 ? -g : e > s ? s + v : e) } if (t.centerInsufficientSlides) { let e = 0; if (h.forEach(s => { e += s + (t.spaceBetween ? t.spaceBetween : 0) }), e -= t.spaceBetween, e < a) { const t = (a - e) / 2; p.forEach((e, s) => { p[s] = e - t }), u.forEach((e, s) => { u[s] = e + t }) } } f.extend(e, { slides: o, snapGrid: p, slidesGrid: u, slidesSizesGrid: h }), d !== l && e.emit("slidesLengthChange"), p.length !== b && (e.params.watchOverflow && e.checkOverflow(), e.emit("snapGridLengthChange")), u.length !== y && e.emit("slidesGridLengthChange"), (t.watchSlidesProgress || t.watchSlidesVisibility) && e.updateSlidesOffset() }, updateAutoHeight: function (e) { const t = this, s = []; let a, i = 0; if ("number" == typeof e ? t.setTransition(e) : !0 === e && t.setTransition(t.params.speed), "auto" !== t.params.slidesPerView && t.params.slidesPerView > 1) if (t.params.centeredSlides) t.visibleSlides.each((e, t) => { s.push(t) }); else for (a = 0; a < Math.ceil(t.params.slidesPerView); a += 1) { const e = t.activeIndex + a; if (e > t.slides.length) break; s.push(t.slides.eq(e)[0]) } else s.push(t.slides.eq(t.activeIndex)[0]); for (a = 0; a < s.length; a += 1)if (void 0 !== s[a]) { const e = s[a].offsetHeight; i = e > i ? e : i } i && t.$wrapperEl.css("height", i + "px") }, updateSlidesOffset: function () { const e = this, t = e.slides; for (let s = 0; s < t.length; s += 1)t[s].swiperSlideOffset = e.isHorizontal() ? t[s].offsetLeft : t[s].offsetTop }, updateSlidesProgress: function (e = this && this.translate || 0) { const t = this, s = t.params, { slides: a, rtlTranslate: i } = t; if (0 === a.length) return; void 0 === a[0].swiperSlideOffset && t.updateSlidesOffset(); let n = -e; i && (n = e), a.removeClass(s.slideVisibleClass), t.visibleSlidesIndexes = [], t.visibleSlides = []; for (let e = 0; e < a.length; e += 1) { const r = a[e], l = (n + (s.centeredSlides ? t.minTranslate() : 0) - r.swiperSlideOffset) / (r.swiperSlideSize + s.spaceBetween); if (s.watchSlidesVisibility || s.centeredSlides && s.autoHeight) { const i = -(n - r.swiperSlideOffset), l = i + t.slidesSizesGrid[e]; (i >= 0 && i < t.size - 1 || l > 1 && l <= t.size || i <= 0 && l >= t.size) && (t.visibleSlides.push(r), t.visibleSlidesIndexes.push(e), a.eq(e).addClass(s.slideVisibleClass)) } r.progress = i ? -l : l } t.visibleSlides = u(t.visibleSlides) }, updateProgress: function (e) { const t = this; if (void 0 === e) { const s = t.rtlTranslate ? -1 : 1; e = t && t.translate && t.translate * s || 0 } const s = t.params, a = t.maxTranslate() - t.minTranslate(); let { progress: i, isBeginning: n, isEnd: r } = t; const l = n, o = r; 0 === a ? (i = 0, n = !0, r = !0) : (i = (e - t.minTranslate()) / a, n = i <= 0, r = i >= 1), f.extend(t, { progress: i, isBeginning: n, isEnd: r }), (s.watchSlidesProgress || s.watchSlidesVisibility || s.centeredSlides && s.autoHeight) && t.updateSlidesProgress(e), n && !l && t.emit("reachBeginning toEdge"), r && !o && t.emit("reachEnd toEdge"), (l && !n || o && !r) && t.emit("fromEdge"), t.emit("progress", i) }, updateSlidesClasses: function () { const e = this, { slides: t, params: s, $wrapperEl: a, activeIndex: i, realIndex: n } = e, r = e.virtual && s.virtual.enabled; let l; t.removeClass(`${s.slideActiveClass} ${s.slideNextClass} ${s.slidePrevClass} ${s.slideDuplicateActiveClass} ${s.slideDuplicateNextClass} ${s.slideDuplicatePrevClass}`), l = r ? e.$wrapperEl.find(`.${s.slideClass}[data-swiper-slide-index="${i}"]`) : t.eq(i), l.addClass(s.slideActiveClass), s.loop && (l.hasClass(s.slideDuplicateClass) ? a.children(`.${s.slideClass}:not(.${s.slideDuplicateClass})[data-swiper-slide-index="${n}"]`).addClass(s.slideDuplicateActiveClass) : a.children(`.${s.slideClass}.${s.slideDuplicateClass}[data-swiper-slide-index="${n}"]`).addClass(s.slideDuplicateActiveClass)); let o = l.nextAll("." + s.slideClass).eq(0).addClass(s.slideNextClass); s.loop && 0 === o.length && (o = t.eq(0), o.addClass(s.slideNextClass)); let d = l.prevAll("." + s.slideClass).eq(0).addClass(s.slidePrevClass); s.loop && 0 === d.length && (d = t.eq(-1), d.addClass(s.slidePrevClass)), s.loop && (o.hasClass(s.slideDuplicateClass) ? a.children(`.${s.slideClass}:not(.${s.slideDuplicateClass})[data-swiper-slide-index="${o.attr("data-swiper-slide-index")}"]`).addClass(s.slideDuplicateNextClass) : a.children(`.${s.slideClass}.${s.slideDuplicateClass}[data-swiper-slide-index="${o.attr("data-swiper-slide-index")}"]`).addClass(s.slideDuplicateNextClass), d.hasClass(s.slideDuplicateClass) ? a.children(`.${s.slideClass}:not(.${s.slideDuplicateClass})[data-swiper-slide-index="${d.attr("data-swiper-slide-index")}"]`).addClass(s.slideDuplicatePrevClass) : a.children(`.${s.slideClass}.${s.slideDuplicateClass}[data-swiper-slide-index="${d.attr("data-swiper-slide-index")}"]`).addClass(s.slideDuplicatePrevClass)) }, updateActiveIndex: function (e) { const t = this, s = t.rtlTranslate ? t.translate : -t.translate, { slidesGrid: a, snapGrid: i, params: n, activeIndex: r, realIndex: l, snapIndex: o } = t; let d, c = e; if (void 0 === c) { for (let e = 0; e < a.length; e += 1)void 0 !== a[e + 1] ? s >= a[e] && s < a[e + 1] - (a[e + 1] - a[e]) / 2 ? c = e : s >= a[e] && s < a[e + 1] && (c = e + 1) : s >= a[e] && (c = e); n.normalizeSlideIndex && (c < 0 || void 0 === c) && (c = 0) } if (i.indexOf(s) >= 0) d = i.indexOf(s); else { const e = Math.min(n.slidesPerGroupSkip, c); d = e + Math.floor((c - e) / n.slidesPerGroup) } if (d >= i.length && (d = i.length - 1), c === r) return void (d !== o && (t.snapIndex = d, t.emit("snapIndexChange"))); const p = parseInt(t.slides.eq(c).attr("data-swiper-slide-index") || c, 10); f.extend(t, { snapIndex: d, realIndex: p, previousIndex: r, activeIndex: c }), t.emit("activeIndexChange"), t.emit("snapIndexChange"), l !== p && t.emit("realIndexChange"), (t.initialized || t.params.runCallbacksOnInit) && t.emit("slideChange") }, updateClickedSlide: function (e) { const t = this, s = t.params, a = u(e.target).closest("." + s.slideClass)[0]; let i = !1; if (a) for (let e = 0; e < t.slides.length; e += 1)t.slides[e] === a && (i = !0); if (!a || !i) return t.clickedSlide = void 0, void (t.clickedIndex = void 0); t.clickedSlide = a, t.virtual && t.params.virtual.enabled ? t.clickedIndex = parseInt(u(a).attr("data-swiper-slide-index"), 10) : t.clickedIndex = u(a).index(), s.slideToClickedSlide && void 0 !== t.clickedIndex && t.clickedIndex !== t.activeIndex && t.slideToClickedSlide() } }; var y = { getTranslate: function (e = (this.isHorizontal() ? "x" : "y")) { const { params: t, rtlTranslate: s, translate: a, $wrapperEl: i } = this; if (t.virtualTranslate) return s ? -a : a; if (t.cssMode) return a; let n = f.getTranslate(i[0], e); return s && (n = -n), n || 0 }, setTranslate: function (e, t) { const s = this, { rtlTranslate: a, params: i, $wrapperEl: n, wrapperEl: r, progress: l } = s; let o, d = 0, c = 0; s.isHorizontal() ? d = a ? -e : e : c = e, i.roundLengths && (d = Math.floor(d), c = Math.floor(c)), i.cssMode ? r[s.isHorizontal() ? "scrollLeft" : "scrollTop"] = s.isHorizontal() ? -d : -c : i.virtualTranslate || n.transform(`translate3d(${d}px, ${c}px, 0px)`), s.previousTranslate = s.translate, s.translate = s.isHorizontal() ? d : c; const p = s.maxTranslate() - s.minTranslate(); o = 0 === p ? 0 : (e - s.minTranslate()) / p, o !== l && s.updateProgress(e), s.emit("setTranslate", s.translate, t) }, minTranslate: function () { return -this.snapGrid[0] }, maxTranslate: function () { return -this.snapGrid[this.snapGrid.length - 1] }, translateTo: function (e = 0, t = this.params.speed, s = !0, a = !0, i) { const n = this, { params: r, wrapperEl: l } = n; if (n.animating && r.preventInteractionOnTransition) return !1; const o = n.minTranslate(), d = n.maxTranslate(); let c; if (c = a && e > o ? o : a && e < d ? d : e, n.updateProgress(c), r.cssMode) { const e = n.isHorizontal(); return 0 === t ? l[e ? "scrollLeft" : "scrollTop"] = -c : l.scrollTo ? l.scrollTo({ [e ? "left" : "top"]: -c, behavior: "smooth" }) : l[e ? "scrollLeft" : "scrollTop"] = -c, !0 } return 0 === t ? (n.setTransition(0), n.setTranslate(c), s && (n.emit("beforeTransitionStart", t, i), n.emit("transitionEnd"))) : (n.setTransition(t), n.setTranslate(c), s && (n.emit("beforeTransitionStart", t, i), n.emit("transitionStart")), n.animating || (n.animating = !0, n.onTranslateToWrapperTransitionEnd || (n.onTranslateToWrapperTransitionEnd = function (e) { n && !n.destroyed && e.target === this && (n.$wrapperEl[0].removeEventListener("transitionend", n.onTranslateToWrapperTransitionEnd), n.$wrapperEl[0].removeEventListener("webkitTransitionEnd", n.onTranslateToWrapperTransitionEnd), n.onTranslateToWrapperTransitionEnd = null, delete n.onTranslateToWrapperTransitionEnd, s && n.emit("transitionEnd")) }), n.$wrapperEl[0].addEventListener("transitionend", n.onTranslateToWrapperTransitionEnd), n.$wrapperEl[0].addEventListener("webkitTransitionEnd", n.onTranslateToWrapperTransitionEnd))), !0 } }; var w = { setTransition: function (e, t) { const s = this; s.params.cssMode || s.$wrapperEl.transition(e), s.emit("setTransition", e, t) }, transitionStart: function (e = !0, t) { const s = this, { activeIndex: a, params: i, previousIndex: n } = s; if (i.cssMode) return; i.autoHeight && s.updateAutoHeight(); let r = t; if (r || (r = a > n ? "next" : a < n ? "prev" : "reset"), s.emit("transitionStart"), e && a !== n) { if ("reset" === r) return void s.emit("slideResetTransitionStart"); s.emit("slideChangeTransitionStart"), "next" === r ? s.emit("slideNextTransitionStart") : s.emit("slidePrevTransitionStart") } }, transitionEnd: function (e = !0, t) { const s = this, { activeIndex: a, previousIndex: i, params: n } = s; if (s.animating = !1, n.cssMode) return; s.setTransition(0); let r = t; if (r || (r = a > i ? "next" : a < i ? "prev" : "reset"), s.emit("transitionEnd"), e && a !== i) { if ("reset" === r) return void s.emit("slideResetTransitionEnd"); s.emit("slideChangeTransitionEnd"), "next" === r ? s.emit("slideNextTransitionEnd") : s.emit("slidePrevTransitionEnd") } } }; var x = { slideTo: function (e = 0, t = this.params.speed, s = !0, a) { const i = this; let n = e; n < 0 && (n = 0); const { params: r, snapGrid: l, slidesGrid: o, previousIndex: d, activeIndex: c, rtlTranslate: p, wrapperEl: u } = i; if (i.animating && r.preventInteractionOnTransition) return !1; const h = Math.min(i.params.slidesPerGroupSkip, n); let m = h + Math.floor((n - h) / i.params.slidesPerGroup); m >= l.length && (m = l.length - 1), (c || r.initialSlide || 0) === (d || 0) && s && i.emit("beforeSlideChangeStart"); const f = -l[m]; if (i.updateProgress(f), r.normalizeSlideIndex) for (let e = 0; e < o.length; e += 1)-Math.floor(100 * f) >= Math.floor(100 * o[e]) && (n = e); if (i.initialized && n !== c) { if (!i.allowSlideNext && f < i.translate && f < i.minTranslate()) return !1; if (!i.allowSlidePrev && f > i.translate && f > i.maxTranslate() && (c || 0) !== n) return !1 } let g; if (g = n > c ? "next" : n < c ? "prev" : "reset", p && -f === i.translate || !p && f === i.translate) return i.updateActiveIndex(n), r.autoHeight && i.updateAutoHeight(), i.updateSlidesClasses(), "slide" !== r.effect && i.setTranslate(f), "reset" !== g && (i.transitionStart(s, g), i.transitionEnd(s, g)), !1; if (r.cssMode) { const e = i.isHorizontal(); let s = -f; return p && (s = u.scrollWidth - u.offsetWidth - s), 0 === t ? u[e ? "scrollLeft" : "scrollTop"] = s : u.scrollTo ? u.scrollTo({ [e ? "left" : "top"]: s, behavior: "smooth" }) : u[e ? "scrollLeft" : "scrollTop"] = s, !0 } return 0 === t ? (i.setTransition(0), i.setTranslate(f), i.updateActiveIndex(n), i.updateSlidesClasses(), i.emit("beforeTransitionStart", t, a), i.transitionStart(s, g), i.transitionEnd(s, g)) : (i.setTransition(t), i.setTranslate(f), i.updateActiveIndex(n), i.updateSlidesClasses(), i.emit("beforeTransitionStart", t, a), i.transitionStart(s, g), i.animating || (i.animating = !0, i.onSlideToWrapperTransitionEnd || (i.onSlideToWrapperTransitionEnd = function (e) { i && !i.destroyed && e.target === this && (i.$wrapperEl[0].removeEventListener("transitionend", i.onSlideToWrapperTransitionEnd), i.$wrapperEl[0].removeEventListener("webkitTransitionEnd", i.onSlideToWrapperTransitionEnd), i.onSlideToWrapperTransitionEnd = null, delete i.onSlideToWrapperTransitionEnd, i.transitionEnd(s, g)) }), i.$wrapperEl[0].addEventListener("transitionend", i.onSlideToWrapperTransitionEnd), i.$wrapperEl[0].addEventListener("webkitTransitionEnd", i.onSlideToWrapperTransitionEnd))), !0 }, slideToLoop: function (e = 0, t = this.params.speed, s = !0, a) { const i = this; let n = e; return i.params.loop && (n += i.loopedSlides), i.slideTo(n, t, s, a) }, slideNext: function (e = this.params.speed, t = !0, s) { const a = this, { params: i, animating: n } = a, r = a.activeIndex < i.slidesPerGroupSkip ? 1 : i.slidesPerGroup; if (i.loop) { if (n) return !1; a.loopFix(), a._clientLeft = a.$wrapperEl[0].clientLeft } return a.slideTo(a.activeIndex + r, e, t, s) }, slidePrev: function (e = this.params.speed, t = !0, s) { const a = this, { params: i, animating: n, snapGrid: r, slidesGrid: l, rtlTranslate: o } = a; if (i.loop) { if (n) return !1; a.loopFix(), a._clientLeft = a.$wrapperEl[0].clientLeft } function d(e) { return e < 0 ? -Math.floor(Math.abs(e)) : Math.floor(e) } const c = d(o ? a.translate : -a.translate), p = r.map(e => d(e)); l.map(e => d(e)), r[p.indexOf(c)]; let u, h = r[p.indexOf(c) - 1]; return void 0 === h && i.cssMode && r.forEach(e => { !h && c >= e && (h = e) }), void 0 !== h && (u = l.indexOf(h), u < 0 && (u = a.activeIndex - 1)), a.slideTo(u, e, t, s) }, slideReset: function (e = this.params.speed, t = !0, s) { return this.slideTo(this.activeIndex, e, t, s) }, slideToClosest: function (e = this.params.speed, t = !0, s, a = .5) { const i = this; let n = i.activeIndex; const r = Math.min(i.params.slidesPerGroupSkip, n), l = r + Math.floor((n - r) / i.params.slidesPerGroup), o = i.rtlTranslate ? i.translate : -i.translate; if (o >= i.snapGrid[l]) { const e = i.snapGrid[l]; o - e > (i.snapGrid[l + 1] - e) * a && (n += i.params.slidesPerGroup) } else { const e = i.snapGrid[l - 1]; o - e <= (i.snapGrid[l] - e) * a && (n -= i.params.slidesPerGroup) } return n = Math.max(n, 0), n = Math.min(n, i.slidesGrid.length - 1), i.slideTo(n, e, t, s) }, slideToClickedSlide: function () { const e = this, { params: t, $wrapperEl: s } = e, a = "auto" === t.slidesPerView ? e.slidesPerViewDynamic() : t.slidesPerView; let i, n = e.clickedIndex; if (t.loop) { if (e.animating) return; i = parseInt(u(e.clickedSlide).attr("data-swiper-slide-index"), 10), t.centeredSlides ? n < e.loopedSlides - a / 2 || n > e.slides.length - e.loopedSlides + a / 2 ? (e.loopFix(), n = s.children(`.${t.slideClass}[data-swiper-slide-index="${i}"]:not(.${t.slideDuplicateClass})`).eq(0).index(), f.nextTick(() => { e.slideTo(n) })) : e.slideTo(n) : n > e.slides.length - a ? (e.loopFix(), n = s.children(`.${t.slideClass}[data-swiper-slide-index="${i}"]:not(.${t.slideDuplicateClass})`).eq(0).index(), f.nextTick(() => { e.slideTo(n) })) : e.slideTo(n) } else e.slideTo(n) } }; var E = { loopCreate: function () { const e = this, { params: t, $wrapperEl: s } = e; s.children(`.${t.slideClass}.${t.slideDuplicateClass}`).remove(); let a = s.children("." + t.slideClass); if (t.loopFillGroupWithBlank) { const e = t.slidesPerGroup - a.length % t.slidesPerGroup; if (e !== t.slidesPerGroup) { for (let a = 0; a < e; a += 1) { const e = u(o.createElement("div")).addClass(`${t.slideClass} ${t.slideBlankClass}`); s.append(e) } a = s.children("." + t.slideClass) } } "auto" !== t.slidesPerView || t.loopedSlides || (t.loopedSlides = a.length), e.loopedSlides = Math.ceil(parseFloat(t.loopedSlides || t.slidesPerView, 10)), e.loopedSlides += t.loopAdditionalSlides, e.loopedSlides > a.length && (e.loopedSlides = a.length); const i = [], n = []; a.each((t, s) => { const r = u(s); t < e.loopedSlides && n.push(s), t < a.length && t >= a.length - e.loopedSlides && i.push(s), r.attr("data-swiper-slide-index", t) }); for (let e = 0; e < n.length; e += 1)s.append(u(n[e].cloneNode(!0)).addClass(t.slideDuplicateClass)); for (let e = i.length - 1; e >= 0; e -= 1)s.prepend(u(i[e].cloneNode(!0)).addClass(t.slideDuplicateClass)) }, loopFix: function () { const e = this; e.emit("beforeLoopFix"); const { activeIndex: t, slides: s, loopedSlides: a, allowSlidePrev: i, allowSlideNext: n, snapGrid: r, rtlTranslate: l } = e; let o; e.allowSlidePrev = !0, e.allowSlideNext = !0; const d = -r[t] - e.getTranslate(); if (t < a) { o = s.length - 3 * a + t, o += a; e.slideTo(o, 0, !1, !0) && 0 !== d && e.setTranslate((l ? -e.translate : e.translate) - d) } else if (t >= s.length - a) { o = -s.length + t + a, o += a; e.slideTo(o, 0, !1, !0) && 0 !== d && e.setTranslate((l ? -e.translate : e.translate) - d) } e.allowSlidePrev = i, e.allowSlideNext = n, e.emit("loopFix") }, loopDestroy: function () { const { $wrapperEl: e, params: t, slides: s } = this; e.children(`.${t.slideClass}.${t.slideDuplicateClass},.${t.slideClass}.${t.slideBlankClass}`).remove(), s.removeAttr("data-swiper-slide-index") } }; var S = { setGrabCursor: function (e) { if (g.touch || !this.params.simulateTouch || this.params.watchOverflow && this.isLocked || this.params.cssMode) return; const t = this.el; t.style.cursor = "move", t.style.cursor = e ? "-webkit-grabbing" : "-webkit-grab", t.style.cursor = e ? "-moz-grabbin" : "-moz-grab", t.style.cursor = e ? "grabbing" : "grab" }, unsetGrabCursor: function () { g.touch || this.params.watchOverflow && this.isLocked || this.params.cssMode || (this.el.style.cursor = "") } }; var T = { appendSlide: function (e) { const t = this, { $wrapperEl: s, params: a } = t; if (a.loop && t.loopDestroy(), "object" == typeof e && "length" in e) for (let t = 0; t < e.length; t += 1)e[t] && s.append(e[t]); else s.append(e); a.loop && t.loopCreate(), a.observer && g.observer || t.update() }, prependSlide: function (e) { const t = this, { params: s, $wrapperEl: a, activeIndex: i } = t; s.loop && t.loopDestroy(); let n = i + 1; if ("object" == typeof e && "length" in e) { for (let t = 0; t < e.length; t += 1)e[t] && a.prepend(e[t]); n = i + e.length } else a.prepend(e); s.loop && t.loopCreate(), s.observer && g.observer || t.update(), t.slideTo(n, 0, !1) }, addSlide: function (e, t) { const s = this, { $wrapperEl: a, params: i, activeIndex: n } = s; let r = n; i.loop && (r -= s.loopedSlides, s.loopDestroy(), s.slides = a.children("." + i.slideClass)); const l = s.slides.length; if (e <= 0) return void s.prependSlide(t); if (e >= l) return void s.appendSlide(t); let o = r > e ? r + 1 : r; const d = []; for (let t = l - 1; t >= e; t -= 1) { const e = s.slides.eq(t); e.remove(), d.unshift(e) } if ("object" == typeof t && "length" in t) { for (let e = 0; e < t.length; e += 1)t[e] && a.append(t[e]); o = r > e ? r + t.length : r } else a.append(t); for (let e = 0; e < d.length; e += 1)a.append(d[e]); i.loop && s.loopCreate(), i.observer && g.observer || s.update(), i.loop ? s.slideTo(o + s.loopedSlides, 0, !1) : s.slideTo(o, 0, !1) }, removeSlide: function (e) { const t = this, { params: s, $wrapperEl: a, activeIndex: i } = t; let n = i; s.loop && (n -= t.loopedSlides, t.loopDestroy(), t.slides = a.children("." + s.slideClass)); let r, l = n; if ("object" == typeof e && "length" in e) { for (let s = 0; s < e.length; s += 1)r = e[s], t.slides[r] && t.slides.eq(r).remove(), r < l && (l -= 1); l = Math.max(l, 0) } else r = e, t.slides[r] && t.slides.eq(r).remove(), r < l && (l -= 1), l = Math.max(l, 0); s.loop && t.loopCreate(), s.observer && g.observer || t.update(), s.loop ? t.slideTo(l + t.loopedSlides, 0, !1) : t.slideTo(l, 0, !1) }, removeAllSlides: function () { const e = this, t = []; for (let s = 0; s < e.slides.length; s += 1)t.push(s); e.removeSlide(t) } }; const C = function () { const e = c.navigator.platform, t = c.navigator.userAgent, s = { ios: !1, android: !1, androidChrome: !1, desktop: !1, iphone: !1, ipod: !1, ipad: !1, edge: !1, ie: !1, firefox: !1, macos: !1, windows: !1, cordova: !(!c.cordova && !c.phonegap), phonegap: !(!c.cordova && !c.phonegap), electron: !1 }, a = c.screen.width, i = c.screen.height, n = t.match(/(Android);?[\s\/]+([\d.]+)?/); let r = t.match(/(iPad).*OS\s([\d_]+)/); const l = t.match(/(iPod)(.*OS\s([\d_]+))?/), o = !r && t.match(/(iPhone\sOS|iOS)\s([\d_]+)/), d = t.indexOf("MSIE ") >= 0 || t.indexOf("Trident/") >= 0, p = t.indexOf("Edge/") >= 0, u = t.indexOf("Gecko/") >= 0 && t.indexOf("Firefox/") >= 0, h = "Win32" === e, m = t.toLowerCase().indexOf("electron") >= 0; let f = "MacIntel" === e; return !r && f && g.touch && (1024 === a && 1366 === i || 834 === a && 1194 === i || 834 === a && 1112 === i || 768 === a && 1024 === i) && (r = t.match(/(Version)\/([\d.]+)/), f = !1), s.ie = d, s.edge = p, s.firefox = u, n && !h && (s.os = "android", s.osVersion = n[2], s.android = !0, s.androidChrome = t.toLowerCase().indexOf("chrome") >= 0), (r || o || l) && (s.os = "ios", s.ios = !0), o && !l && (s.osVersion = o[2].replace(/_/g, "."), s.iphone = !0), r && (s.osVersion = r[2].replace(/_/g, "."), s.ipad = !0), l && (s.osVersion = l[3] ? l[3].replace(/_/g, ".") : null, s.ipod = !0), s.ios && s.osVersion && t.indexOf("Version/") >= 0 && "10" === s.osVersion.split(".")[0] && (s.osVersion = t.toLowerCase().split("version/")[1].split(" ")[0]), s.webView = !(!(o || r || l) || !t.match(/.*AppleWebKit(?!.*Safari)/i) && !c.navigator.standalone) || c.matchMedia && c.matchMedia("(display-mode: standalone)").matches, s.webview = s.webView, s.standalone = s.webView, s.desktop = !(s.ios || s.android) || m, s.desktop && (s.electron = m, s.macos = f, s.windows = h, s.macos && (s.os = "macos"), s.windows && (s.os = "windows")), s.pixelRatio = c.devicePixelRatio || 1, s }(); function M(e) { const t = this, s = t.touchEventsData, { params: a, touches: i } = t; if (t.animating && a.preventInteractionOnTransition) return; let n = e; n.originalEvent && (n = n.originalEvent); const r = u(n.target); if ("wrapper" === a.touchEventsTarget && !r.closest(t.wrapperEl).length) return; if (s.isTouchEvent = "touchstart" === n.type, !s.isTouchEvent && "which" in n && 3 === n.which) return; if (!s.isTouchEvent && "button" in n && n.button > 0) return; if (s.isTouched && s.isMoved) return; if (a.noSwiping && r.closest(a.noSwipingSelector ? a.noSwipingSelector : "." + a.noSwipingClass)[0]) return void (t.allowClick = !0); if (a.swipeHandler && !r.closest(a.swipeHandler)[0]) return; i.currentX = "touchstart" === n.type ? n.targetTouches[0].pageX : n.pageX, i.currentY = "touchstart" === n.type ? n.targetTouches[0].pageY : n.pageY; const l = i.currentX, d = i.currentY, p = a.edgeSwipeDetection || a.iOSEdgeSwipeDetection, h = a.edgeSwipeThreshold || a.iOSEdgeSwipeThreshold; if (!p || !(l <= h || l >= c.screen.width - h)) { if (f.extend(s, { isTouched: !0, isMoved: !1, allowTouchCallbacks: !0, isScrolling: void 0, startMoving: void 0 }), i.startX = l, i.startY = d, s.touchStartTime = f.now(), t.allowClick = !0, t.updateSize(), t.swipeDirection = void 0, a.threshold > 0 && (s.allowThresholdMove = !1), "touchstart" !== n.type) { let e = !0; r.is(s.formElements) && (e = !1), o.activeElement && u(o.activeElement).is(s.formElements) && o.activeElement !== r[0] && o.activeElement.blur(); const i = e && t.allowTouchMove && a.touchStartPreventDefault; (a.touchStartForcePreventDefault || i) && n.preventDefault() } t.emit("touchStart", n) } } function $(e) { const t = this, s = t.touchEventsData, { params: a, touches: i, rtlTranslate: n } = t; let r = e; if (r.originalEvent && (r = r.originalEvent), !s.isTouched) return void (s.startMoving && s.isScrolling && t.emit("touchMoveOpposite", r)); if (s.isTouchEvent && "touchmove" !== r.type) return; const l = "touchmove" === r.type && r.targetTouches && (r.targetTouches[0] || r.changedTouches[0]), d = "touchmove" === r.type ? l.pageX : r.pageX, c = "touchmove" === r.type ? l.pageY : r.pageY; if (r.preventedByNestedSwiper) return i.startX = d, void (i.startY = c); if (!t.allowTouchMove) return t.allowClick = !1, void (s.isTouched && (f.extend(i, { startX: d, startY: c, currentX: d, currentY: c }), s.touchStartTime = f.now())); if (s.isTouchEvent && a.touchReleaseOnEdges && !a.loop) if (t.isVertical()) { if (c < i.startY && t.translate <= t.maxTranslate() || c > i.startY && t.translate >= t.minTranslate()) return s.isTouched = !1, void (s.isMoved = !1) } else if (d < i.startX && t.translate <= t.maxTranslate() || d > i.startX && t.translate >= t.minTranslate()) return; if (s.isTouchEvent && o.activeElement && r.target === o.activeElement && u(r.target).is(s.formElements)) return s.isMoved = !0, void (t.allowClick = !1); if (s.allowTouchCallbacks && t.emit("touchMove", r), r.targetTouches && r.targetTouches.length > 1) return; i.currentX = d, i.currentY = c; const p = i.currentX - i.startX, h = i.currentY - i.startY; if (t.params.threshold && Math.sqrt(p ** 2 + h ** 2) < t.params.threshold) return; if (void 0 === s.isScrolling) { let e; t.isHorizontal() && i.currentY === i.startY || t.isVertical() && i.currentX === i.startX ? s.isScrolling = !1 : p * p + h * h >= 25 && (e = 180 * Math.atan2(Math.abs(h), Math.abs(p)) / Math.PI, s.isScrolling = t.isHorizontal() ? e > a.touchAngle : 90 - e > a.touchAngle) } if (s.isScrolling && t.emit("touchMoveOpposite", r), void 0 === s.startMoving && (i.currentX === i.startX && i.currentY === i.startY || (s.startMoving = !0)), s.isScrolling) return void (s.isTouched = !1); if (!s.startMoving) return; t.allowClick = !1, !a.cssMode && r.cancelable && r.preventDefault(), a.touchMoveStopPropagation && !a.nested && r.stopPropagation(), s.isMoved || (a.loop && t.loopFix(), s.startTranslate = t.getTranslate(), t.setTransition(0), t.animating && t.$wrapperEl.trigger("webkitTransitionEnd transitionend"), s.allowMomentumBounce = !1, !a.grabCursor || !0 !== t.allowSlideNext && !0 !== t.allowSlidePrev || t.setGrabCursor(!0), t.emit("sliderFirstMove", r)), t.emit("sliderMove", r), s.isMoved = !0; let m = t.isHorizontal() ? p : h; i.diff = m, m *= a.touchRatio, n && (m = -m), t.swipeDirection = m > 0 ? "prev" : "next", s.currentTranslate = m + s.startTranslate; let g = !0, v = a.resistanceRatio; if (a.touchReleaseOnEdges && (v = 0), m > 0 && s.currentTranslate > t.minTranslate() ? (g = !1, a.resistance && (s.currentTranslate = t.minTranslate() - 1 + (-t.minTranslate() + s.startTranslate + m) ** v)) : m < 0 && s.currentTranslate < t.maxTranslate() && (g = !1, a.resistance && (s.currentTranslate = t.maxTranslate() + 1 - (t.maxTranslate() - s.startTranslate - m) ** v)), g && (r.preventedByNestedSwiper = !0), !t.allowSlideNext && "next" === t.swipeDirection && s.currentTranslate < s.startTranslate && (s.currentTranslate = s.startTranslate), !t.allowSlidePrev && "prev" === t.swipeDirection && s.currentTranslate > s.startTranslate && (s.currentTranslate = s.startTranslate), a.threshold > 0) { if (!(Math.abs(m) > a.threshold || s.allowThresholdMove)) return void (s.currentTranslate = s.startTranslate); if (!s.allowThresholdMove) return s.allowThresholdMove = !0, i.startX = i.currentX, i.startY = i.currentY, s.currentTranslate = s.startTranslate, void (i.diff = t.isHorizontal() ? i.currentX - i.startX : i.currentY - i.startY) } a.followFinger && !a.cssMode && ((a.freeMode || a.watchSlidesProgress || a.watchSlidesVisibility) && (t.updateActiveIndex(), t.updateSlidesClasses()), a.freeMode && (0 === s.velocities.length && s.velocities.push({ position: i[t.isHorizontal() ? "startX" : "startY"], time: s.touchStartTime }), s.velocities.push({ position: i[t.isHorizontal() ? "currentX" : "currentY"], time: f.now() })), t.updateProgress(s.currentTranslate), t.setTranslate(s.currentTranslate)) } function k(e) { const t = this, s = t.touchEventsData, { params: a, touches: i, rtlTranslate: n, $wrapperEl: r, slidesGrid: l, snapGrid: o } = t; let d = e; if (d.originalEvent && (d = d.originalEvent), s.allowTouchCallbacks && t.emit("touchEnd", d), s.allowTouchCallbacks = !1, !s.isTouched) return s.isMoved && a.grabCursor && t.setGrabCursor(!1), s.isMoved = !1, void (s.startMoving = !1); a.grabCursor && s.isMoved && s.isTouched && (!0 === t.allowSlideNext || !0 === t.allowSlidePrev) && t.setGrabCursor(!1); const c = f.now(), p = c - s.touchStartTime; if (t.allowClick && (t.updateClickedSlide(d), t.emit("tap click", d), p < 300 && c - s.lastClickTime < 300 && t.emit("doubleTap doubleClick", d)), s.lastClickTime = f.now(), f.nextTick(() => { t.destroyed || (t.allowClick = !0) }), !s.isTouched || !s.isMoved || !t.swipeDirection || 0 === i.diff || s.currentTranslate === s.startTranslate) return s.isTouched = !1, s.isMoved = !1, void (s.startMoving = !1); let u; if (s.isTouched = !1, s.isMoved = !1, s.startMoving = !1, u = a.followFinger ? n ? t.translate : -t.translate : -s.currentTranslate, a.cssMode) return; if (a.freeMode) { if (u < -t.minTranslate()) return void t.slideTo(t.activeIndex); if (u > -t.maxTranslate()) return void (t.slides.length < o.length ? t.slideTo(o.length - 1) : t.slideTo(t.slides.length - 1)); if (a.freeModeMomentum) { if (s.velocities.length > 1) { const e = s.velocities.pop(), i = s.velocities.pop(), n = e.position - i.position, r = e.time - i.time; t.velocity = n / r, t.velocity /= 2, Math.abs(t.velocity) < a.freeModeMinimumVelocity && (t.velocity = 0), (r > 150 || f.now() - e.time > 300) && (t.velocity = 0) } else t.velocity = 0; t.velocity *= a.freeModeMomentumVelocityRatio, s.velocities.length = 0; let e = 1e3 * a.freeModeMomentumRatio; const i = t.velocity * e; let l = t.translate + i; n && (l = -l); let d, c = !1; const p = 20 * Math.abs(t.velocity) * a.freeModeMomentumBounceRatio; let u; if (l < t.maxTranslate()) a.freeModeMomentumBounce ? (l + t.maxTranslate() < -p && (l = t.maxTranslate() - p), d = t.maxTranslate(), c = !0, s.allowMomentumBounce = !0) : l = t.maxTranslate(), a.loop && a.centeredSlides && (u = !0); else if (l > t.minTranslate()) a.freeModeMomentumBounce ? (l - t.minTranslate() > p && (l = t.minTranslate() + p), d = t.minTranslate(), c = !0, s.allowMomentumBounce = !0) : l = t.minTranslate(), a.loop && a.centeredSlides && (u = !0); else if (a.freeModeSticky) { let e; for (let t = 0; t < o.length; t += 1)if (o[t] > -l) { e = t; break } l = Math.abs(o[e] - l) < Math.abs(o[e - 1] - l) || "next" === t.swipeDirection ? o[e] : o[e - 1], l = -l } if (u && t.once("transitionEnd", () => { t.loopFix() }), 0 !== t.velocity) { if (e = n ? Math.abs((-l - t.translate) / t.velocity) : Math.abs((l - t.translate) / t.velocity), a.freeModeSticky) { const s = Math.abs((n ? -l : l) - t.translate), i = t.slidesSizesGrid[t.activeIndex]; e = s < i ? a.speed : s < 2 * i ? 1.5 * a.speed : 2.5 * a.speed } } else if (a.freeModeSticky) return void t.slideToClosest(); a.freeModeMomentumBounce && c ? (t.updateProgress(d), t.setTransition(e), t.setTranslate(l), t.transitionStart(!0, t.swipeDirection), t.animating = !0, r.transitionEnd(() => { t && !t.destroyed && s.allowMomentumBounce && (t.emit("momentumBounce"), t.setTransition(a.speed), setTimeout(() => { t.setTranslate(d), r.transitionEnd(() => { t && !t.destroyed && t.transitionEnd() }) }, 0)) })) : t.velocity ? (t.updateProgress(l), t.setTransition(e), t.setTranslate(l), t.transitionStart(!0, t.swipeDirection), t.animating || (t.animating = !0, r.transitionEnd(() => { t && !t.destroyed && t.transitionEnd() }))) : t.updateProgress(l), t.updateActiveIndex(), t.updateSlidesClasses() } else if (a.freeModeSticky) return void t.slideToClosest(); return void ((!a.freeModeMomentum || p >= a.longSwipesMs) && (t.updateProgress(), t.updateActiveIndex(), t.updateSlidesClasses())) } let h = 0, m = t.slidesSizesGrid[0]; for (let e = 0; e < l.length; e += e < a.slidesPerGroupSkip ? 1 : a.slidesPerGroup) { const t = e < a.slidesPerGroupSkip - 1 ? 1 : a.slidesPerGroup; void 0 !== l[e + t] ? u >= l[e] && u < l[e + t] && (h = e, m = l[e + t] - l[e]) : u >= l[e] && (h = e, m = l[l.length - 1] - l[l.length - 2]) } const g = (u - l[h]) / m, v = h < a.slidesPerGroupSkip - 1 ? 1 : a.slidesPerGroup; if (p > a.longSwipesMs) { if (!a.longSwipes) return void t.slideTo(t.activeIndex); "next" === t.swipeDirection && (g >= a.longSwipesRatio ? t.slideTo(h + v) : t.slideTo(h)), "prev" === t.swipeDirection && (g > 1 - a.longSwipesRatio ? t.slideTo(h + v) : t.slideTo(h)) } else { if (!a.shortSwipes) return void t.slideTo(t.activeIndex); t.navigation && (d.target === t.navigation.nextEl || d.target === t.navigation.prevEl) ? d.target === t.navigation.nextEl ? t.slideTo(h + v) : t.slideTo(h) : ("next" === t.swipeDirection && t.slideTo(h + v), "prev" === t.swipeDirection && t.slideTo(h)) } } function P() { const e = this, { params: t, el: s } = e; if (s && 0 === s.offsetWidth) return; t.breakpoints && e.setBreakpoint(); const { allowSlideNext: a, allowSlidePrev: i, snapGrid: n } = e; e.allowSlideNext = !0, e.allowSlidePrev = !0, e.updateSize(), e.updateSlides(), e.updateSlidesClasses(), ("auto" === t.slidesPerView || t.slidesPerView > 1) && e.isEnd && !e.isBeginning && !e.params.centeredSlides ? e.slideTo(e.slides.length - 1, 0, !1, !0) : e.slideTo(e.activeIndex, 0, !1, !0), e.autoplay && e.autoplay.running && e.autoplay.paused && e.autoplay.run(), e.allowSlidePrev = i, e.allowSlideNext = a, e.params.watchOverflow && n !== e.snapGrid && e.checkOverflow() } function z(e) { const t = this; t.allowClick || (t.params.preventClicks && e.preventDefault(), t.params.preventClicksPropagation && t.animating && (e.stopPropagation(), e.stopImmediatePropagation())) } function L() { const e = this, { wrapperEl: t, rtlTranslate: s } = e; let a; e.previousTranslate = e.translate, e.isHorizontal() ? e.translate = s ? t.scrollWidth - t.offsetWidth - t.scrollLeft : -t.scrollLeft : e.translate = -t.scrollTop, -0 === e.translate && (e.translate = 0), e.updateActiveIndex(), e.updateSlidesClasses(); const i = e.maxTranslate() - e.minTranslate(); a = 0 === i ? 0 : (e.translate - e.minTranslate()) / i, a !== e.progress && e.updateProgress(s ? -e.translate : e.translate), e.emit("setTranslate", e.translate, !1) } let I = !1; function D() { } var O = { init: !0, direction: "horizontal", touchEventsTarget: "container", initialSlide: 0, speed: 300, cssMode: !1, updateOnWindowResize: !0, preventInteractionOnTransition: !1, edgeSwipeDetection: !1, edgeSwipeThreshold: 20, freeMode: !1, freeModeMomentum: !0, freeModeMomentumRatio: 1, freeModeMomentumBounce: !0, freeModeMomentumBounceRatio: 1, freeModeMomentumVelocityRatio: 1, freeModeSticky: !1, freeModeMinimumVelocity: .02, autoHeight: !1, setWrapperSize: !1, virtualTranslate: !1, effect: "slide", breakpoints: void 0, spaceBetween: 0, slidesPerView: 1, slidesPerColumn: 1, slidesPerColumnFill: "column", slidesPerGroup: 1, slidesPerGroupSkip: 0, centeredSlides: !1, centeredSlidesBounds: !1, slidesOffsetBefore: 0, slidesOffsetAfter: 0, normalizeSlideIndex: !0, centerInsufficientSlides: !1, watchOverflow: !1, roundLengths: !1, touchRatio: 1, touchAngle: 45, simulateTouch: !0, shortSwipes: !0, longSwipes: !0, longSwipesRatio: .5, longSwipesMs: 300, followFinger: !0, allowTouchMove: !0, threshold: 0, touchMoveStopPropagation: !1, touchStartPreventDefault: !0, touchStartForcePreventDefault: !1, touchReleaseOnEdges: !1, uniqueNavElements: !0, resistance: !0, resistanceRatio: .85, watchSlidesProgress: !1, watchSlidesVisibility: !1, grabCursor: !1, preventClicks: !0, preventClicksPropagation: !0, slideToClickedSlide: !1, preloadImages: !0, updateOnImagesReady: !0, loop: !1, loopAdditionalSlides: 0, loopedSlides: null, loopFillGroupWithBlank: !1, allowSlidePrev: !0, allowSlideNext: !0, swipeHandler: null, noSwiping: !0, noSwipingClass: "swiper-no-swiping", noSwipingSelector: null, passiveListeners: !0, containerModifierClass: "swiper-container-", slideClass: "swiper-slide", slideBlankClass: "swiper-slide-invisible-blank", slideActiveClass: "swiper-slide-active", slideDuplicateActiveClass: "swiper-slide-duplicate-active", slideVisibleClass: "swiper-slide-visible", slideDuplicateClass: "swiper-slide-duplicate", slideNextClass: "swiper-slide-next", slideDuplicateNextClass: "swiper-slide-duplicate-next", slidePrevClass: "swiper-slide-prev", slideDuplicatePrevClass: "swiper-slide-duplicate-prev", wrapperClass: "swiper-wrapper", runCallbacksOnInit: !0 }; const A = { update: b, translate: y, transition: w, slide: x, loop: E, grabCursor: S, manipulation: T, events: { attachEvents: function () { const e = this, { params: t, touchEvents: s, el: a, wrapperEl: i } = e; e.onTouchStart = M.bind(e), e.onTouchMove = $.bind(e), e.onTouchEnd = k.bind(e), t.cssMode && (e.onScroll = L.bind(e)), e.onClick = z.bind(e); const n = !!t.nested; if (!g.touch && g.pointerEvents) a.addEventListener(s.start, e.onTouchStart, !1), o.addEventListener(s.move, e.onTouchMove, n), o.addEventListener(s.end, e.onTouchEnd, !1); else { if (g.touch) { const i = !("touchstart" !== s.start || !g.passiveListener || !t.passiveListeners) && { passive: !0, capture: !1 }; a.addEventListener(s.start, e.onTouchStart, i), a.addEventListener(s.move, e.onTouchMove, g.passiveListener ? { passive: !1, capture: n } : n), a.addEventListener(s.end, e.onTouchEnd, i), s.cancel && a.addEventListener(s.cancel, e.onTouchEnd, i), I || (o.addEventListener("touchstart", D), I = !0) } (t.simulateTouch && !C.ios && !C.android || t.simulateTouch && !g.touch && C.ios) && (a.addEventListener("mousedown", e.onTouchStart, !1), o.addEventListener("mousemove", e.onTouchMove, n), o.addEventListener("mouseup", e.onTouchEnd, !1)) } (t.preventClicks || t.preventClicksPropagation) && a.addEventListener("click", e.onClick, !0), t.cssMode && i.addEventListener("scroll", e.onScroll), t.updateOnWindowResize ? e.on(C.ios || C.android ? "resize orientationchange observerUpdate" : "resize observerUpdate", P, !0) : e.on("observerUpdate", P, !0) }, detachEvents: function () { const e = this, { params: t, touchEvents: s, el: a, wrapperEl: i } = e, n = !!t.nested; if (!g.touch && g.pointerEvents) a.removeEventListener(s.start, e.onTouchStart, !1), o.removeEventListener(s.move, e.onTouchMove, n), o.removeEventListener(s.end, e.onTouchEnd, !1); else { if (g.touch) { const i = !("onTouchStart" !== s.start || !g.passiveListener || !t.passiveListeners) && { passive: !0, capture: !1 }; a.removeEventListener(s.start, e.onTouchStart, i), a.removeEventListener(s.move, e.onTouchMove, n), a.removeEventListener(s.end, e.onTouchEnd, i), s.cancel && a.removeEventListener(s.cancel, e.onTouchEnd, i) } (t.simulateTouch && !C.ios && !C.android || t.simulateTouch && !g.touch && C.ios) && (a.removeEventListener("mousedown", e.onTouchStart, !1), o.removeEventListener("mousemove", e.onTouchMove, n), o.removeEventListener("mouseup", e.onTouchEnd, !1)) } (t.preventClicks || t.preventClicksPropagation) && a.removeEventListener("click", e.onClick, !0), t.cssMode && i.removeEventListener("scroll", e.onScroll), e.off(C.ios || C.android ? "resize orientationchange observerUpdate" : "resize observerUpdate", P) } }, breakpoints: { setBreakpoint: function () { const e = this, { activeIndex: t, initialized: s, loopedSlides: a = 0, params: i, $el: n } = e, r = i.breakpoints; if (!r || r && 0 === Object.keys(r).length) return; const l = e.getBreakpoint(r); if (l && e.currentBreakpoint !== l) { const o = l in r ? r[l] : void 0; o && ["slidesPerView", "spaceBetween", "slidesPerGroup", "slidesPerGroupSkip", "slidesPerColumn"].forEach(e => { const t = o[e]; void 0 !== t && (o[e] = "slidesPerView" !== e || "AUTO" !== t && "auto" !== t ? "slidesPerView" === e ? parseFloat(t) : parseInt(t, 10) : "auto") }); const d = o || e.originalParams, c = i.slidesPerColumn > 1, p = d.slidesPerColumn > 1; c && !p ? n.removeClass(`${i.containerModifierClass}multirow ${i.containerModifierClass}multirow-column`) : !c && p && (n.addClass(i.containerModifierClass + "multirow"), "column" === d.slidesPerColumnFill && n.addClass(i.containerModifierClass + "multirow-column")); const u = d.direction && d.direction !== i.direction, h = i.loop && (d.slidesPerView !== i.slidesPerView || u); u && s && e.changeDirection(), f.extend(e.params, d), f.extend(e, { allowTouchMove: e.params.allowTouchMove, allowSlideNext: e.params.allowSlideNext, allowSlidePrev: e.params.allowSlidePrev }), e.currentBreakpoint = l, h && s && (e.loopDestroy(), e.loopCreate(), e.updateSlides(), e.slideTo(t - a + e.loopedSlides, 0, !1)), e.emit("breakpoint", d) } }, getBreakpoint: function (e) { if (!e) return; let t = !1; const s = Object.keys(e).map(e => { if ("string" == typeof e && 0 === e.indexOf("@")) { const t = parseFloat(e.substr(1)); return { value: c.innerHeight * t, point: e } } return { value: e, point: e } }); s.sort((e, t) => parseInt(e.value, 10) - parseInt(t.value, 10)); for (let e = 0; e < s.length; e += 1) { const { point: a, value: i } = s[e]; i <= c.innerWidth && (t = a) } return t || "max" } }, checkOverflow: { checkOverflow: function () { const e = this, t = e.params, s = e.isLocked, a = e.slides.length > 0 && t.slidesOffsetBefore + t.spaceBetween * (e.slides.length - 1) + e.slides[0].offsetWidth * e.slides.length; t.slidesOffsetBefore && t.slidesOffsetAfter && a ? e.isLocked = a <= e.size : e.isLocked = 1 === e.snapGrid.length, e.allowSlideNext = !e.isLocked, e.allowSlidePrev = !e.isLocked, s !== e.isLocked && e.emit(e.isLocked ? "lock" : "unlock"), s && s !== e.isLocked && (e.isEnd = !1, e.navigation && e.navigation.update()) } }, classes: { addClasses: function () { const { classNames: e, params: t, rtl: s, $el: a } = this, i = []; i.push("initialized"), i.push(t.direction), t.freeMode && i.push("free-mode"), t.autoHeight && i.push("autoheight"), s && i.push("rtl"), t.slidesPerColumn > 1 && (i.push("multirow"), "column" === t.slidesPerColumnFill && i.push("multirow-column")), C.android && i.push("android"), C.ios && i.push("ios"), t.cssMode && i.push("css-mode"), i.forEach(s => { e.push(t.containerModifierClass + s) }), a.addClass(e.join(" ")) }, removeClasses: function () { const { $el: e, classNames: t } = this; e.removeClass(t.join(" ")) } }, images: { loadImage: function (e, t, s, a, i, n) { let r; function l() { n && n() } u(e).parent("picture")[0] || e.complete && i ? l() : t ? (r = new c.Image, r.onload = l, r.onerror = l, a && (r.sizes = a), s && (r.srcset = s), t && (r.src = t)) : l() }, preloadImages: function () { const e = this; function t() { null != e && e && !e.destroyed && (void 0 !== e.imagesLoaded && (e.imagesLoaded += 1), e.imagesLoaded === e.imagesToLoad.length && (e.params.updateOnImagesReady && e.update(), e.emit("imagesReady"))) } e.imagesToLoad = e.$el.find("img"); for (let s = 0; s < e.imagesToLoad.length; s += 1) { const a = e.imagesToLoad[s]; e.loadImage(a, a.currentSrc || a.getAttribute("src"), a.srcset || a.getAttribute("srcset"), a.sizes || a.getAttribute("sizes"), !0, t) } } } }, G = {}; class B extends v { constructor(...e) { let t, s; 1 === e.length && e[0].constructor && e[0].constructor === Object ? s = e[0] : [t, s] = e, s || (s = {}), s = f.extend({}, s), t && !s.el && (s.el = t), super(s), Object.keys(A).forEach(e => { Object.keys(A[e]).forEach(t => { B.prototype[t] || (B.prototype[t] = A[e][t]) }) }); const a = this; void 0 === a.modules && (a.modules = {}), Object.keys(a.modules).forEach(e => { const t = a.modules[e]; if (t.params) { const e = Object.keys(t.params)[0], a = t.params[e]; if ("object" != typeof a || null === a) return; if (!(e in s) || !("enabled" in a)) return; !0 === s[e] && (s[e] = { enabled: !0 }), "object" != typeof s[e] || "enabled" in s[e] || (s[e].enabled = !0), s[e] || (s[e] = { enabled: !1 }) } }); const i = f.extend({}, O); a.useModulesParams(i), a.params = f.extend({}, i, G, s), a.originalParams = f.extend({}, a.params), a.passedParams = f.extend({}, s), a.$ = u; const n = u(a.params.el); if (t = n[0], !t) return; if (n.length > 1) { const e = []; return n.each((t, a) => { const i = f.extend({}, s, { el: a }); e.push(new B(i)) }), e } let r; return t.swiper = a, n.data("swiper", a), t && t.shadowRoot && t.shadowRoot.querySelector ? (r = u(t.shadowRoot.querySelector("." + a.params.wrapperClass)), r.children = e => n.children(e)) : r = n.children("." + a.params.wrapperClass), f.extend(a, { $el: n, el: t, $wrapperEl: r, wrapperEl: r[0], classNames: [], slides: u(), slidesGrid: [], snapGrid: [], slidesSizesGrid: [], isHorizontal: () => "horizontal" === a.params.direction, isVertical: () => "vertical" === a.params.direction, rtl: "rtl" === t.dir.toLowerCase() || "rtl" === n.css("direction"), rtlTranslate: "horizontal" === a.params.direction && ("rtl" === t.dir.toLowerCase() || "rtl" === n.css("direction")), wrongRTL: "-webkit-box" === r.css("display"), activeIndex: 0, realIndex: 0, isBeginning: !0, isEnd: !1, translate: 0, previousTranslate: 0, progress: 0, velocity: 0, animating: !1, allowSlideNext: a.params.allowSlideNext, allowSlidePrev: a.params.allowSlidePrev, touchEvents: function () { const e = ["touchstart", "touchmove", "touchend", "touchcancel"]; let t = ["mousedown", "mousemove", "mouseup"]; return g.pointerEvents && (t = ["pointerdown", "pointermove", "pointerup"]), a.touchEventsTouch = { start: e[0], move: e[1], end: e[2], cancel: e[3] }, a.touchEventsDesktop = { start: t[0], move: t[1], end: t[2] }, g.touch || !a.params.simulateTouch ? a.touchEventsTouch : a.touchEventsDesktop }(), touchEventsData: { isTouched: void 0, isMoved: void 0, allowTouchCallbacks: void 0, touchStartTime: void 0, isScrolling: void 0, currentTranslate: void 0, startTranslate: void 0, allowThresholdMove: void 0, formElements: "input, select, option, textarea, button, video, label", lastClickTime: f.now(), clickTimeout: void 0, velocities: [], allowMomentumBounce: void 0, isTouchEvent: void 0, startMoving: void 0 }, allowClick: !0, allowTouchMove: a.params.allowTouchMove, touches: { startX: 0, startY: 0, currentX: 0, currentY: 0, diff: 0 }, imagesToLoad: [], imagesLoaded: 0 }), a.useModules(), a.params.init && a.init(), a } slidesPerViewDynamic() { const { params: e, slides: t, slidesGrid: s, size: a, activeIndex: i } = this; let n = 1; if (e.centeredSlides) { let e, s = t[i].swiperSlideSize; for (let r = i + 1; r < t.length; r += 1)t[r] && !e && (s += t[r].swiperSlideSize, n += 1, s > a && (e = !0)); for (let r = i - 1; r >= 0; r -= 1)t[r] && !e && (s += t[r].swiperSlideSize, n += 1, s > a && (e = !0)) } else for (let e = i + 1; e < t.length; e += 1)s[e] - s[i] < a && (n += 1); return n } update() { const e = this; if (!e || e.destroyed) return; const { snapGrid: t, params: s } = e; function a() { const t = e.rtlTranslate ? -1 * e.translate : e.translate, s = Math.min(Math.max(t, e.maxTranslate()), e.minTranslate()); e.setTranslate(s), e.updateActiveIndex(), e.updateSlidesClasses() } let i; s.breakpoints && e.setBreakpoint(), e.updateSize(), e.updateSlides(), e.updateProgress(), e.updateSlidesClasses(), e.params.freeMode ? (a(), e.params.autoHeight && e.updateAutoHeight()) : (i = ("auto" === e.params.slidesPerView || e.params.slidesPerView > 1) && e.isEnd && !e.params.centeredSlides ? e.slideTo(e.slides.length - 1, 0, !1, !0) : e.slideTo(e.activeIndex, 0, !1, !0), i || a()), s.watchOverflow && t !== e.snapGrid && e.checkOverflow(), e.emit("update") } changeDirection(e, t = !0) { const s = this, a = s.params.direction; return e || (e = "horizontal" === a ? "vertical" : "horizontal"), e === a || "horizontal" !== e && "vertical" !== e || (s.$el.removeClass(`${s.params.containerModifierClass}${a}`).addClass(`${s.params.containerModifierClass}${e}`), s.params.direction = e, s.slides.each((t, s) => { "vertical" === e ? s.style.width = "" : s.style.height = "" }), s.emit("changeDirection"), t && s.update()), s } init() { const e = this; e.initialized || (e.emit("beforeInit"), e.params.breakpoints && e.setBreakpoint(), e.addClasses(), e.params.loop && e.loopCreate(), e.updateSize(), e.updateSlides(), e.params.watchOverflow && e.checkOverflow(), e.params.grabCursor && e.setGrabCursor(), e.params.preloadImages && e.preloadImages(), e.params.loop ? e.slideTo(e.params.initialSlide + e.loopedSlides, 0, e.params.runCallbacksOnInit) : e.slideTo(e.params.initialSlide, 0, e.params.runCallbacksOnInit), e.attachEvents(), e.initialized = !0, e.emit("init")) } destroy(e = !0, t = !0) { const s = this, { params: a, $el: i, $wrapperEl: n, slides: r } = s; return void 0 === s.params || s.destroyed || (s.emit("beforeDestroy"), s.initialized = !1, s.detachEvents(), a.loop && s.loopDestroy(), t && (s.removeClasses(), i.removeAttr("style"), n.removeAttr("style"), r && r.length && r.removeClass([a.slideVisibleClass, a.slideActiveClass, a.slideNextClass, a.slidePrevClass].join(" ")).removeAttr("style").removeAttr("data-swiper-slide-index")), s.emit("destroy"), Object.keys(s.eventsListeners).forEach(e => { s.off(e) }), !1 !== e && (s.$el[0].swiper = null, s.$el.data("swiper", null), f.deleteProps(s)), s.destroyed = !0), null } static extendDefaults(e) { f.extend(G, e) } static get extendedDefaults() { return G } static get defaults() { return O } static get Class() { return v } static get $() { return u } } var H = { name: "device", proto: { device: C }, static: { device: C } }, N = { name: "support", proto: { support: g }, static: { support: g } }; const q = { isEdge: !!c.navigator.userAgent.match(/Edge/g), isSafari: function () { const e = c.navigator.userAgent.toLowerCase(); return e.indexOf("safari") >= 0 && e.indexOf("chrome") < 0 && e.indexOf("android") < 0 }(), isWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(c.navigator.userAgent) }; var V = { name: "browser", proto: { browser: q }, static: { browser: q } }, X = { name: "resize", create() { const e = this; f.extend(e, { resize: { resizeHandler() { e && !e.destroyed && e.initialized && (e.emit("beforeResize"), e.emit("resize")) }, orientationChangeHandler() { e && !e.destroyed && e.initialized && e.emit("orientationchange") } } }) }, on: { init() { c.addEventListener("resize", this.resize.resizeHandler), c.addEventListener("orientationchange", this.resize.orientationChangeHandler) }, destroy() { c.removeEventListener("resize", this.resize.resizeHandler), c.removeEventListener("orientationchange", this.resize.orientationChangeHandler) } } }; const Y = { func: c.MutationObserver || c.WebkitMutationObserver, attach(e, t = {}) { const s = this, a = new (0, Y.func)(e => { if (1 === e.length) return void s.emit("observerUpdate", e[0]); const t = function () { s.emit("observerUpdate", e[0]) }; c.requestAnimationFrame ? c.requestAnimationFrame(t) : c.setTimeout(t, 0) }); a.observe(e, { attributes: void 0 === t.attributes || t.attributes, childList: void 0 === t.childList || t.childList, characterData: void 0 === t.characterData || t.characterData }), s.observer.observers.push(a) }, init() { const e = this; if (g.observer && e.params.observer) { if (e.params.observeParents) { const t = e.$el.parents(); for (let s = 0; s < t.length; s += 1)e.observer.attach(t[s]) } e.observer.attach(e.$el[0], { childList: e.params.observeSlideChildren }), e.observer.attach(e.$wrapperEl[0], { attributes: !1 }) } }, destroy() { this.observer.observers.forEach(e => { e.disconnect() }), this.observer.observers = [] } }; var F = { name: "observer", params: { observer: !1, observeParents: !1, observeSlideChildren: !1 }, create() { f.extend(this, { observer: { init: Y.init.bind(this), attach: Y.attach.bind(this), destroy: Y.destroy.bind(this), observers: [] } }) }, on: { init() { this.observer.init() }, destroy() { this.observer.destroy() } } }; const W = { update(e) { const t = this, { slidesPerView: s, slidesPerGroup: a, centeredSlides: i } = t.params, { addSlidesBefore: n, addSlidesAfter: r } = t.params.virtual, { from: l, to: o, slides: d, slidesGrid: c, renderSlide: p, offset: u } = t.virtual; t.updateActiveIndex(); const h = t.activeIndex || 0; let m, g, v; m = t.rtlTranslate ? "right" : t.isHorizontal() ? "left" : "top", i ? (g = Math.floor(s / 2) + a + n, v = Math.floor(s / 2) + a + r) : (g = s + (a - 1) + n, v = a + r); const b = Math.max((h || 0) - v, 0), y = Math.min((h || 0) + g, d.length - 1), w = (t.slidesGrid[b] || 0) - (t.slidesGrid[0] || 0); function x() { t.updateSlides(), t.updateProgress(), t.updateSlidesClasses(), t.lazy && t.params.lazy.enabled && t.lazy.load() } if (f.extend(t.virtual, { from: b, to: y, offset: w, slidesGrid: t.slidesGrid }), l === b && o === y && !e) return t.slidesGrid !== c && w !== u && t.slides.css(m, w + "px"), void t.updateProgress(); if (t.params.virtual.renderExternal) return t.params.virtual.renderExternal.call(t, { offset: w, from: b, to: y, slides: function () { const e = []; for (let t = b; t <= y; t += 1)e.push(d[t]); return e }() }), void x(); const E = [], S = []; if (e) t.$wrapperEl.find("." + t.params.slideClass).remove(); else for (let e = l; e <= o; e += 1)(e < b || e > y) && t.$wrapperEl.find(`.${t.params.slideClass}[data-swiper-slide-index="${e}"]`).remove(); for (let t = 0; t < d.length; t += 1)t >= b && t <= y && (void 0 === o || e ? S.push(t) : (t > o && S.push(t), t < l && E.push(t))); S.forEach(e => { t.$wrapperEl.append(p(d[e], e)) }), E.sort((e, t) => t - e).forEach(e => { t.$wrapperEl.prepend(p(d[e], e)) }), t.$wrapperEl.children(".swiper-slide").css(m, w + "px"), x() }, renderSlide(e, t) { const s = this, a = s.params.virtual; if (a.cache && s.virtual.cache[t]) return s.virtual.cache[t]; const i = a.renderSlide ? u(a.renderSlide.call(s, e, t)) : u(`<div class="${s.params.slideClass}" data-swiper-slide-index="${t}">${e}</div>`); return i.attr("data-swiper-slide-index") || i.attr("data-swiper-slide-index", t), a.cache && (s.virtual.cache[t] = i), i }, appendSlide(e) { const t = this; if ("object" == typeof e && "length" in e) for (let s = 0; s < e.length; s += 1)e[s] && t.virtual.slides.push(e[s]); else t.virtual.slides.push(e); t.virtual.update(!0) }, prependSlide(e) { const t = this, s = t.activeIndex; let a = s + 1, i = 1; if (Array.isArray(e)) { for (let s = 0; s < e.length; s += 1)e[s] && t.virtual.slides.unshift(e[s]); a = s + e.length, i = e.length } else t.virtual.slides.unshift(e); if (t.params.virtual.cache) { const e = t.virtual.cache, s = {}; Object.keys(e).forEach(t => { const a = e[t], n = a.attr("data-swiper-slide-index"); n && a.attr("data-swiper-slide-index", parseInt(n, 10) + 1), s[parseInt(t, 10) + i] = a }), t.virtual.cache = s } t.virtual.update(!0), t.slideTo(a, 0) }, removeSlide(e) { const t = this; if (null == e) return; let s = t.activeIndex; if (Array.isArray(e)) for (let a = e.length - 1; a >= 0; a -= 1)t.virtual.slides.splice(e[a], 1), t.params.virtual.cache && delete t.virtual.cache[e[a]], e[a] < s && (s -= 1), s = Math.max(s, 0); else t.virtual.slides.splice(e, 1), t.params.virtual.cache && delete t.virtual.cache[e], e < s && (s -= 1), s = Math.max(s, 0); t.virtual.update(!0), t.slideTo(s, 0) }, removeAllSlides() { const e = this; e.virtual.slides = [], e.params.virtual.cache && (e.virtual.cache = {}), e.virtual.update(!0), e.slideTo(0, 0) } }; var R = { name: "virtual", params: { virtual: { enabled: !1, slides: [], cache: !0, renderSlide: null, renderExternal: null, addSlidesBefore: 0, addSlidesAfter: 0 } }, create() { f.extend(this, { virtual: { update: W.update.bind(this), appendSlide: W.appendSlide.bind(this), prependSlide: W.prependSlide.bind(this), removeSlide: W.removeSlide.bind(this), removeAllSlides: W.removeAllSlides.bind(this), renderSlide: W.renderSlide.bind(this), slides: this.params.virtual.slides, cache: {} } }) }, on: { beforeInit() { const e = this; if (!e.params.virtual.enabled) return; e.classNames.push(e.params.containerModifierClass + "virtual"); const t = { watchSlidesProgress: !0 }; f.extend(e.params, t), f.extend(e.originalParams, t), e.params.initialSlide || e.virtual.update() }, setTranslate() { this.params.virtual.enabled && this.virtual.update() } } }; const _ = { handle(e) { const t = this, { rtlTranslate: s } = t; let a = e; a.originalEvent && (a = a.originalEvent); const i = a.keyCode || a.charCode, n = t.params.keyboard.pageUpDown, r = n && 33 === i, l = n && 34 === i, d = 37 === i, p = 39 === i, u = 38 === i, h = 40 === i; if (!t.allowSlideNext && (t.isHorizontal() && p || t.isVertical() && h || l)) return !1; if (!t.allowSlidePrev && (t.isHorizontal() && d || t.isVertical() && u || r)) return !1; if (!(a.shiftKey || a.altKey || a.ctrlKey || a.metaKey || o.activeElement && o.activeElement.nodeName && ("input" === o.activeElement.nodeName.toLowerCase() || "textarea" === o.activeElement.nodeName.toLowerCase()))) { if (t.params.keyboard.onlyInViewport && (r || l || d || p || u || h)) { let e = !1; if (t.$el.parents("." + t.params.slideClass).length > 0 && 0 === t.$el.parents("." + t.params.slideActiveClass).length) return; const a = c.innerWidth, i = c.innerHeight, n = t.$el.offset(); s && (n.left -= t.$el[0].scrollLeft); const r = [[n.left, n.top], [n.left + t.width, n.top], [n.left, n.top + t.height], [n.left + t.width, n.top + t.height]]; for (let t = 0; t < r.length; t += 1) { const s = r[t]; s[0] >= 0 && s[0] <= a && s[1] >= 0 && s[1] <= i && (e = !0) } if (!e) return } t.isHorizontal() ? ((r || l || d || p) && (a.preventDefault ? a.preventDefault() : a.returnValue = !1), ((l || p) && !s || (r || d) && s) && t.slideNext(), ((r || d) && !s || (l || p) && s) && t.slidePrev()) : ((r || l || u || h) && (a.preventDefault ? a.preventDefault() : a.returnValue = !1), (l || h) && t.slideNext(), (r || u) && t.slidePrev()), t.emit("keyPress", i) } }, enable() { this.keyboard.enabled || (u(o).on("keydown", this.keyboard.handle), this.keyboard.enabled = !0) }, disable() { this.keyboard.enabled && (u(o).off("keydown", this.keyboard.handle), this.keyboard.enabled = !1) } }; var j = { name: "keyboard", params: { keyboard: { enabled: !1, onlyInViewport: !0, pageUpDown: !0 } }, create() { f.extend(this, { keyboard: { enabled: !1, enable: _.enable.bind(this), disable: _.disable.bind(this), handle: _.handle.bind(this) } }) }, on: { init() { const e = this; e.params.keyboard.enabled && e.keyboard.enable() }, destroy() { const e = this; e.keyboard.enabled && e.keyboard.disable() } } }; const K = { lastScrollTime: f.now(), lastEventBeforeSnap: void 0, recentWheelEvents: [], event: () => c.navigator.userAgent.indexOf("firefox") > -1 ? "DOMMouseScroll" : function () { let e = "onwheel" in o; if (!e) { const t = o.createElement("div"); t.setAttribute("onwheel", "return;"), e = "function" == typeof t.onwheel } return !e && o.implementation && o.implementation.hasFeature && !0 !== o.implementation.hasFeature("", "") && (e = o.implementation.hasFeature("Events.wheel", "3.0")), e }() ? "wheel" : "mousewheel", normalize(e) { let t = 0, s = 0, a = 0, i = 0; return "detail" in e && (s = e.detail), "wheelDelta" in e && (s = -e.wheelDelta / 120), "wheelDeltaY" in e && (s = -e.wheelDeltaY / 120), "wheelDeltaX" in e && (t = -e.wheelDeltaX / 120), "axis" in e && e.axis === e.HORIZONTAL_AXIS && (t = s, s = 0), a = 10 * t, i = 10 * s, "deltaY" in e && (i = e.deltaY), "deltaX" in e && (a = e.deltaX), e.shiftKey && !a && (a = i, i = 0), (a || i) && e.deltaMode && (1 === e.deltaMode ? (a *= 40, i *= 40) : (a *= 800, i *= 800)), a && !t && (t = a < 1 ? -1 : 1), i && !s && (s = i < 1 ? -1 : 1), { spinX: t, spinY: s, pixelX: a, pixelY: i } }, handleMouseEnter() { this.mouseEntered = !0 }, handleMouseLeave() { this.mouseEntered = !1 }, handle(e) { let t = e; const s = this, a = s.params.mousewheel; s.params.cssMode && t.preventDefault(); let i = s.$el; if ("container" !== s.params.mousewheel.eventsTarged && (i = u(s.params.mousewheel.eventsTarged)), !s.mouseEntered && !i[0].contains(t.target) && !a.releaseOnEdges) return !0; t.originalEvent && (t = t.originalEvent); let n = 0; const r = s.rtlTranslate ? -1 : 1, l = K.normalize(t); if (a.forceToAxis) if (s.isHorizontal()) { if (!(Math.abs(l.pixelX) > Math.abs(l.pixelY))) return !0; n = -l.pixelX * r } else { if (!(Math.abs(l.pixelY) > Math.abs(l.pixelX))) return !0; n = -l.pixelY } else n = Math.abs(l.pixelX) > Math.abs(l.pixelY) ? -l.pixelX * r : -l.pixelY; if (0 === n) return !0; if (a.invert && (n = -n), s.params.freeMode) { const e = { time: f.now(), delta: Math.abs(n), direction: Math.sign(n) }, { lastEventBeforeSnap: i } = s.mousewheel, r = i && e.time < i.time + 500 && e.delta <= i.delta && e.direction === i.direction; if (!r) { s.mousewheel.lastEventBeforeSnap = void 0, s.params.loop && s.loopFix(); let i = s.getTranslate() + n * a.sensitivity; const l = s.isBeginning, o = s.isEnd; if (i >= s.minTranslate() && (i = s.minTranslate()), i <= s.maxTranslate() && (i = s.maxTranslate()), s.setTransition(0), s.setTranslate(i), s.updateProgress(), s.updateActiveIndex(), s.updateSlidesClasses(), (!l && s.isBeginning || !o && s.isEnd) && s.updateSlidesClasses(), s.params.freeModeSticky) { clearTimeout(s.mousewheel.timeout), s.mousewheel.timeout = void 0; const t = s.mousewheel.recentWheelEvents; t.length >= 15 && t.shift(); const a = t.length ? t[t.length - 1] : void 0, i = t[0]; if (t.push(e), a && (e.delta > a.delta || e.direction !== a.direction)) t.splice(0); else if (t.length >= 15 && e.time - i.time < 500 && i.delta - e.delta >= 1 && e.delta <= 6) { const a = n > 0 ? .8 : .2; s.mousewheel.lastEventBeforeSnap = e, t.splice(0), s.mousewheel.timeout = f.nextTick(() => { s.slideToClosest(s.params.speed, !0, void 0, a) }, 0) } s.mousewheel.timeout || (s.mousewheel.timeout = f.nextTick(() => { s.mousewheel.lastEventBeforeSnap = e, t.splice(0), s.slideToClosest(s.params.speed, !0, void 0, .5) }, 500)) } if (r || s.emit("scroll", t), s.params.autoplay && s.params.autoplayDisableOnInteraction && s.autoplay.stop(), i === s.minTranslate() || i === s.maxTranslate()) return !0 } } else { const t = { time: f.now(), delta: Math.abs(n), direction: Math.sign(n), raw: e }, a = s.mousewheel.recentWheelEvents; a.length >= 2 && a.shift(); const i = a.length ? a[a.length - 1] : void 0; if (a.push(t), i ? (t.direction !== i.direction || t.delta > i.delta || t.time > i.time + 150) && s.mousewheel.animateSlider(t) : s.mousewheel.animateSlider(t), s.mousewheel.releaseScroll(t)) return !0 } return t.preventDefault ? t.preventDefault() : t.returnValue = !1, !1 }, animateSlider(e) { const t = this; return e.delta >= 6 && f.now() - t.mousewheel.lastScrollTime < 60 || (e.direction < 0 ? t.isEnd && !t.params.loop || t.animating || (t.slideNext(), t.emit("scroll", e.raw)) : t.isBeginning && !t.params.loop || t.animating || (t.slidePrev(), t.emit("scroll", e.raw)), t.mousewheel.lastScrollTime = (new c.Date).getTime(), !1) }, releaseScroll(e) { const t = this, s = t.params.mousewheel; if (e.direction < 0) { if (t.isEnd && !t.params.loop && s.releaseOnEdges) return !0 } else if (t.isBeginning && !t.params.loop && s.releaseOnEdges) return !0; return !1 }, enable() { const e = this, t = K.event(); if (e.params.cssMode) return e.wrapperEl.removeEventListener(t, e.mousewheel.handle), !0; if (!t) return !1; if (e.mousewheel.enabled) return !1; let s = e.$el; return "container" !== e.params.mousewheel.eventsTarged && (s = u(e.params.mousewheel.eventsTarged)), s.on("mouseenter", e.mousewheel.handleMouseEnter), s.on("mouseleave", e.mousewheel.handleMouseLeave), s.on(t, e.mousewheel.handle), e.mousewheel.enabled = !0, !0 }, disable() { const e = this, t = K.event(); if (e.params.cssMode) return e.wrapperEl.addEventListener(t, e.mousewheel.handle), !0; if (!t) return !1; if (!e.mousewheel.enabled) return !1; let s = e.$el; return "container" !== e.params.mousewheel.eventsTarged && (s = u(e.params.mousewheel.eventsTarged)), s.off(t, e.mousewheel.handle), e.mousewheel.enabled = !1, !0 } }; const U = { update() { const e = this, t = e.params.navigation; if (e.params.loop) return; const { $nextEl: s, $prevEl: a } = e.navigation; a && a.length > 0 && (e.isBeginning ? a.addClass(t.disabledClass) : a.removeClass(t.disabledClass), a[e.params.watchOverflow && e.isLocked ? "addClass" : "removeClass"](t.lockClass)), s && s.length > 0 && (e.isEnd ? s.addClass(t.disabledClass) : s.removeClass(t.disabledClass), s[e.params.watchOverflow && e.isLocked ? "addClass" : "removeClass"](t.lockClass)) }, onPrevClick(e) { e.preventDefault(), this.isBeginning && !this.params.loop || this.slidePrev() }, onNextClick(e) { e.preventDefault(), this.isEnd && !this.params.loop || this.slideNext() }, init() { const e = this, t = e.params.navigation; if (!t.nextEl && !t.prevEl) return; let s, a; t.nextEl && (s = u(t.nextEl), e.params.uniqueNavElements && "string" == typeof t.nextEl && s.length > 1 && 1 === e.$el.find(t.nextEl).length && (s = e.$el.find(t.nextEl))), t.prevEl && (a = u(t.prevEl), e.params.uniqueNavElements && "string" == typeof t.prevEl && a.length > 1 && 1 === e.$el.find(t.prevEl).length && (a = e.$el.find(t.prevEl))), s && s.length > 0 && s.on("click", e.navigation.onNextClick), a && a.length > 0 && a.on("click", e.navigation.onPrevClick), f.extend(e.navigation, { $nextEl: s, nextEl: s && s[0], $prevEl: a, prevEl: a && a[0] }) }, destroy() { const e = this, { $nextEl: t, $prevEl: s } = e.navigation; t && t.length && (t.off("click", e.navigation.onNextClick), t.removeClass(e.params.navigation.disabledClass)), s && s.length && (s.off("click", e.navigation.onPrevClick), s.removeClass(e.params.navigation.disabledClass)) } }; const Z = { update() { const e = this, t = e.rtl, s = e.params.pagination; if (!s.el || !e.pagination.el || !e.pagination.$el || 0 === e.pagination.$el.length) return; const a = e.virtual && e.params.virtual.enabled ? e.virtual.slides.length : e.slides.length, i = e.pagination.$el; let n; const r = e.params.loop ? Math.ceil((a - 2 * e.loopedSlides) / e.params.slidesPerGroup) : e.snapGrid.length; if (e.params.loop ? (n = Math.ceil((e.activeIndex - e.loopedSlides) / e.params.slidesPerGroup), n > a - 1 - 2 * e.loopedSlides && (n -= a - 2 * e.loopedSlides), n > r - 1 && (n -= r), n < 0 && "bullets" !== e.params.paginationType && (n = r + n)) : n = void 0 !== e.snapIndex ? e.snapIndex : e.activeIndex || 0, "bullets" === s.type && e.pagination.bullets && e.pagination.bullets.length > 0) { const a = e.pagination.bullets; let r, l, o; if (s.dynamicBullets && (e.pagination.bulletSize = a.eq(0)[e.isHorizontal() ? "outerWidth" : "outerHeight"](!0), i.css(e.isHorizontal() ? "width" : "height", e.pagination.bulletSize * (s.dynamicMainBullets + 4) + "px"), s.dynamicMainBullets > 1 && void 0 !== e.previousIndex && (e.pagination.dynamicBulletIndex += n - e.previousIndex, e.pagination.dynamicBulletIndex > s.dynamicMainBullets - 1 ? e.pagination.dynamicBulletIndex = s.dynamicMainBullets - 1 : e.pagination.dynamicBulletIndex < 0 && (e.pagination.dynamicBulletIndex = 0)), r = n - e.pagination.dynamicBulletIndex, l = r + (Math.min(a.length, s.dynamicMainBullets) - 1), o = (l + r) / 2), a.removeClass(`${s.bulletActiveClass} ${s.bulletActiveClass}-next ${s.bulletActiveClass}-next-next ${s.bulletActiveClass}-prev ${s.bulletActiveClass}-prev-prev ${s.bulletActiveClass}-main`), i.length > 1) a.each((e, t) => { const a = u(t), i = a.index(); i === n && a.addClass(s.bulletActiveClass), s.dynamicBullets && (i >= r && i <= l && a.addClass(s.bulletActiveClass + "-main"), i === r && a.prev().addClass(s.bulletActiveClass + "-prev").prev().addClass(s.bulletActiveClass + "-prev-prev"), i === l && a.next().addClass(s.bulletActiveClass + "-next").next().addClass(s.bulletActiveClass + "-next-next")) }); else { const t = a.eq(n), i = t.index(); if (t.addClass(s.bulletActiveClass), s.dynamicBullets) { const t = a.eq(r), n = a.eq(l); for (let e = r; e <= l; e += 1)a.eq(e).addClass(s.bulletActiveClass + "-main"); if (e.params.loop) if (i >= a.length - s.dynamicMainBullets) { for (let e = s.dynamicMainBullets; e >= 0; e -= 1)a.eq(a.length - e).addClass(s.bulletActiveClass + "-main"); a.eq(a.length - s.dynamicMainBullets - 1).addClass(s.bulletActiveClass + "-prev") } else t.prev().addClass(s.bulletActiveClass + "-prev").prev().addClass(s.bulletActiveClass + "-prev-prev"), n.next().addClass(s.bulletActiveClass + "-next").next().addClass(s.bulletActiveClass + "-next-next"); else t.prev().addClass(s.bulletActiveClass + "-prev").prev().addClass(s.bulletActiveClass + "-prev-prev"), n.next().addClass(s.bulletActiveClass + "-next").next().addClass(s.bulletActiveClass + "-next-next") } } if (s.dynamicBullets) { const i = Math.min(a.length, s.dynamicMainBullets + 4), n = (e.pagination.bulletSize * i - e.pagination.bulletSize) / 2 - o * e.pagination.bulletSize, r = t ? "right" : "left"; a.css(e.isHorizontal() ? r : "top", n + "px") } } if ("fraction" === s.type && (i.find("." + s.currentClass).text(s.formatFractionCurrent(n + 1)), i.find("." + s.totalClass).text(s.formatFractionTotal(r))), "progressbar" === s.type) { let t; t = s.progressbarOpposite ? e.isHorizontal() ? "vertical" : "horizontal" : e.isHorizontal() ? "horizontal" : "vertical"; const a = (n + 1) / r; let l = 1, o = 1; "horizontal" === t ? l = a : o = a, i.find("." + s.progressbarFillClass).transform(`translate3d(0,0,0) scaleX(${l}) scaleY(${o})`).transition(e.params.speed) } "custom" === s.type && s.renderCustom ? (i.html(s.renderCustom(e, n + 1, r)), e.emit("paginationRender", e, i[0])) : e.emit("paginationUpdate", e, i[0]), i[e.params.watchOverflow && e.isLocked ? "addClass" : "removeClass"](s.lockClass) }, render() { const e = this, t = e.params.pagination; if (!t.el || !e.pagination.el || !e.pagination.$el || 0 === e.pagination.$el.length) return; const s = e.virtual && e.params.virtual.enabled ? e.virtual.slides.length : e.slides.length, a = e.pagination.$el; let i = ""; if ("bullets" === t.type) { const n = e.params.loop ? Math.ceil((s - 2 * e.loopedSlides) / e.params.slidesPerGroup) : e.snapGrid.length; for (let s = 0; s < n; s += 1)t.renderBullet ? i += t.renderBullet.call(e, s, t.bulletClass) : i += `<${t.bulletElement} class="${t.bulletClass}"></${t.bulletElement}>`; a.html(i), e.pagination.bullets = a.find("." + t.bulletClass) } "fraction" === t.type && (i = t.renderFraction ? t.renderFraction.call(e, t.currentClass, t.totalClass) : `<span class="${t.currentClass}"></span> / <span class="${t.totalClass}"></span>`, a.html(i)), "progressbar" === t.type && (i = t.renderProgressbar ? t.renderProgressbar.call(e, t.progressbarFillClass) : `<span class="${t.progressbarFillClass}"></span>`, a.html(i)), "custom" !== t.type && e.emit("paginationRender", e.pagination.$el[0]) }, init() { const e = this, t = e.params.pagination; if (!t.el) return; let s = u(t.el); 0 !== s.length && (e.params.uniqueNavElements && "string" == typeof t.el && s.length > 1 && (s = e.$el.find(t.el)), "bullets" === t.type && t.clickable && s.addClass(t.clickableClass), s.addClass(t.modifierClass + t.type), "bullets" === t.type && t.dynamicBullets && (s.addClass(`${t.modifierClass}${t.type}-dynamic`), e.pagination.dynamicBulletIndex = 0, t.dynamicMainBullets < 1 && (t.dynamicMainBullets = 1)), "progressbar" === t.type && t.progressbarOpposite && s.addClass(t.progressbarOppositeClass), t.clickable && s.on("click", "." + t.bulletClass, (function (t) { t.preventDefault(); let s = u(this).index() * e.params.slidesPerGroup; e.params.loop && (s += e.loopedSlides), e.slideTo(s) })), f.extend(e.pagination, { $el: s, el: s[0] })) }, destroy() { const e = this.params.pagination; if (!e.el || !this.pagination.el || !this.pagination.$el || 0 === this.pagination.$el.length) return; const t = this.pagination.$el; t.removeClass(e.hiddenClass), t.removeClass(e.modifierClass + e.type), this.pagination.bullets && this.pagination.bullets.removeClass(e.bulletActiveClass), e.clickable && t.off("click", "." + e.bulletClass) } }; const Q = { setTranslate() { const e = this; if (!e.params.scrollbar.el || !e.scrollbar.el) return; const { scrollbar: t, rtlTranslate: s, progress: a } = e, { dragSize: i, trackSize: n, $dragEl: r, $el: l } = t, o = e.params.scrollbar; let d = i, c = (n - i) * a; s ? (c = -c, c > 0 ? (d = i - c, c = 0) : -c + i > n && (d = n + c)) : c < 0 ? (d = i + c, c = 0) : c + i > n && (d = n - c), e.isHorizontal() ? (r.transform(`translate3d(${c}px, 0, 0)`), r[0].style.width = d + "px") : (r.transform(`translate3d(0px, ${c}px, 0)`), r[0].style.height = d + "px"), o.hide && (clearTimeout(e.scrollbar.timeout), l[0].style.opacity = 1, e.scrollbar.timeout = setTimeout(() => { l[0].style.opacity = 0, l.transition(400) }, 1e3)) }, setTransition(e) { this.params.scrollbar.el && this.scrollbar.el && this.scrollbar.$dragEl.transition(e) }, updateSize() { const e = this; if (!e.params.scrollbar.el || !e.scrollbar.el) return; const { scrollbar: t } = e, { $dragEl: s, $el: a } = t; s[0].style.width = "", s[0].style.height = ""; const i = e.isHorizontal() ? a[0].offsetWidth : a[0].offsetHeight, n = e.size / e.virtualSize, r = n * (i / e.size); let l; l = "auto" === e.params.scrollbar.dragSize ? i * n : parseInt(e.params.scrollbar.dragSize, 10), e.isHorizontal() ? s[0].style.width = l + "px" : s[0].style.height = l + "px", a[0].style.display = n >= 1 ? "none" : "", e.params.scrollbar.hide && (a[0].style.opacity = 0), f.extend(t, { trackSize: i, divider: n, moveDivider: r, dragSize: l }), t.$el[e.params.watchOverflow && e.isLocked ? "addClass" : "removeClass"](e.params.scrollbar.lockClass) }, getPointerPosition(e) { return this.isHorizontal() ? "touchstart" === e.type || "touchmove" === e.type ? e.targetTouches[0].clientX : e.clientX : "touchstart" === e.type || "touchmove" === e.type ? e.targetTouches[0].clientY : e.clientY }, setDragPosition(e) { const { scrollbar: t, rtlTranslate: s } = this, { $el: a, dragSize: i, trackSize: n, dragStartPos: r } = t; let l; l = (t.getPointerPosition(e) - a.offset()[this.isHorizontal() ? "left" : "top"] - (null !== r ? r : i / 2)) / (n - i), l = Math.max(Math.min(l, 1), 0), s && (l = 1 - l); const o = this.minTranslate() + (this.maxTranslate() - this.minTranslate()) * l; this.updateProgress(o), this.setTranslate(o), this.updateActiveIndex(), this.updateSlidesClasses() }, onDragStart(e) { const t = this, s = t.params.scrollbar, { scrollbar: a, $wrapperEl: i } = t, { $el: n, $dragEl: r } = a; t.scrollbar.isTouched = !0, t.scrollbar.dragStartPos = e.target === r[0] || e.target === r ? a.getPointerPosition(e) - e.target.getBoundingClientRect()[t.isHorizontal() ? "left" : "top"] : null, e.preventDefault(), e.stopPropagation(), i.transition(100), r.transition(100), a.setDragPosition(e), clearTimeout(t.scrollbar.dragTimeout), n.transition(0), s.hide && n.css("opacity", 1), t.params.cssMode && t.$wrapperEl.css("scroll-snap-type", "none"), t.emit("scrollbarDragStart", e) }, onDragMove(e) { const { scrollbar: t, $wrapperEl: s } = this, { $el: a, $dragEl: i } = t; this.scrollbar.isTouched && (e.preventDefault ? e.preventDefault() : e.returnValue = !1, t.setDragPosition(e), s.transition(0), a.transition(0), i.transition(0), this.emit("scrollbarDragMove", e)) }, onDragEnd(e) { const t = this, s = t.params.scrollbar, { scrollbar: a, $wrapperEl: i } = t, { $el: n } = a; t.scrollbar.isTouched && (t.scrollbar.isTouched = !1, t.params.cssMode && (t.$wrapperEl.css("scroll-snap-type", ""), i.transition("")), s.hide && (clearTimeout(t.scrollbar.dragTimeout), t.scrollbar.dragTimeout = f.nextTick(() => { n.css("opacity", 0), n.transition(400) }, 1e3)), t.emit("scrollbarDragEnd", e), s.snapOnRelease && t.slideToClosest()) }, enableDraggable() { const e = this; if (!e.params.scrollbar.el) return; const { scrollbar: t, touchEventsTouch: s, touchEventsDesktop: a, params: i } = e, n = t.$el[0], r = !(!g.passiveListener || !i.passiveListeners) && { passive: !1, capture: !1 }, l = !(!g.passiveListener || !i.passiveListeners) && { passive: !0, capture: !1 }; g.touch ? (n.addEventListener(s.start, e.scrollbar.onDragStart, r), n.addEventListener(s.move, e.scrollbar.onDragMove, r), n.addEventListener(s.end, e.scrollbar.onDragEnd, l)) : (n.addEventListener(a.start, e.scrollbar.onDragStart, r), o.addEventListener(a.move, e.scrollbar.onDragMove, r), o.addEventListener(a.end, e.scrollbar.onDragEnd, l)) }, disableDraggable() { const e = this; if (!e.params.scrollbar.el) return; const { scrollbar: t, touchEventsTouch: s, touchEventsDesktop: a, params: i } = e, n = t.$el[0], r = !(!g.passiveListener || !i.passiveListeners) && { passive: !1, capture: !1 }, l = !(!g.passiveListener || !i.passiveListeners) && { passive: !0, capture: !1 }; g.touch ? (n.removeEventListener(s.start, e.scrollbar.onDragStart, r), n.removeEventListener(s.move, e.scrollbar.onDragMove, r), n.removeEventListener(s.end, e.scrollbar.onDragEnd, l)) : (n.removeEventListener(a.start, e.scrollbar.onDragStart, r), o.removeEventListener(a.move, e.scrollbar.onDragMove, r), o.removeEventListener(a.end, e.scrollbar.onDragEnd, l)) }, init() { const e = this; if (!e.params.scrollbar.el) return; const { scrollbar: t, $el: s } = e, a = e.params.scrollbar; let i = u(a.el); e.params.uniqueNavElements && "string" == typeof a.el && i.length > 1 && 1 === s.find(a.el).length && (i = s.find(a.el)); let n = i.find("." + e.params.scrollbar.dragClass); 0 === n.length && (n = u(`<div class="${e.params.scrollbar.dragClass}"></div>`), i.append(n)), f.extend(t, { $el: i, el: i[0], $dragEl: n, dragEl: n[0] }), a.draggable && t.enableDraggable() }, destroy() { this.scrollbar.disableDraggable() } }; const J = { setTransform(e, t) { const { rtl: s } = this, a = u(e), i = s ? -1 : 1, n = a.attr("data-swiper-parallax") || "0"; let r = a.attr("data-swiper-parallax-x"), l = a.attr("data-swiper-parallax-y"); const o = a.attr("data-swiper-parallax-scale"), d = a.attr("data-swiper-parallax-opacity"); if (r || l ? (r = r || "0", l = l || "0") : this.isHorizontal() ? (r = n, l = "0") : (l = n, r = "0"), r = r.indexOf("%") >= 0 ? parseInt(r, 10) * t * i + "%" : r * t * i + "px", l = l.indexOf("%") >= 0 ? parseInt(l, 10) * t + "%" : l * t + "px", null != d) { const e = d - (d - 1) * (1 - Math.abs(t)); a[0].style.opacity = e } if (null == o) a.transform(`translate3d(${r}, ${l}, 0px)`); else { const e = o - (o - 1) * (1 - Math.abs(t)); a.transform(`translate3d(${r}, ${l}, 0px) scale(${e})`) } }, setTranslate() { const e = this, { $el: t, slides: s, progress: a, snapGrid: i } = e; t.children("[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]").each((t, s) => { e.parallax.setTransform(s, a) }), s.each((t, s) => { let n = s.progress; e.params.slidesPerGroup > 1 && "auto" !== e.params.slidesPerView && (n += Math.ceil(t / 2) - a * (i.length - 1)), n = Math.min(Math.max(n, -1), 1), u(s).find("[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]").each((t, s) => { e.parallax.setTransform(s, n) }) }) }, setTransition(e = this.params.speed) { const { $el: t } = this; t.find("[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]").each((t, s) => { const a = u(s); let i = parseInt(a.attr("data-swiper-parallax-duration"), 10) || e; 0 === e && (i = 0), a.transition(i) }) } }; const ee = { getDistanceBetweenTouches(e) { if (e.targetTouches.length < 2) return 1; const t = e.targetTouches[0].pageX, s = e.targetTouches[0].pageY, a = e.targetTouches[1].pageX, i = e.targetTouches[1].pageY; return Math.sqrt((a - t) ** 2 + (i - s) ** 2) }, onGestureStart(e) { const t = this, s = t.params.zoom, a = t.zoom, { gesture: i } = a; if (a.fakeGestureTouched = !1, a.fakeGestureMoved = !1, !g.gestures) { if ("touchstart" !== e.type || "touchstart" === e.type && e.targetTouches.length < 2) return; a.fakeGestureTouched = !0, i.scaleStart = ee.getDistanceBetweenTouches(e) } i.$slideEl && i.$slideEl.length || (i.$slideEl = u(e.target).closest("." + t.params.slideClass), 0 === i.$slideEl.length && (i.$slideEl = t.slides.eq(t.activeIndex)), i.$imageEl = i.$slideEl.find("img, svg, canvas, picture, .swiper-zoom-target"), i.$imageWrapEl = i.$imageEl.parent("." + s.containerClass), i.maxRatio = i.$imageWrapEl.attr("data-swiper-zoom") || s.maxRatio, 0 !== i.$imageWrapEl.length) ? (i.$imageEl && i.$imageEl.transition(0), t.zoom.isScaling = !0) : i.$imageEl = void 0 }, onGestureChange(e) { const t = this.params.zoom, s = this.zoom, { gesture: a } = s; if (!g.gestures) { if ("touchmove" !== e.type || "touchmove" === e.type && e.targetTouches.length < 2) return; s.fakeGestureMoved = !0, a.scaleMove = ee.getDistanceBetweenTouches(e) } a.$imageEl && 0 !== a.$imageEl.length && (s.scale = g.gestures ? e.scale * s.currentScale : a.scaleMove / a.scaleStart * s.currentScale, s.scale > a.maxRatio && (s.scale = a.maxRatio - 1 + (s.scale - a.maxRatio + 1) ** .5), s.scale < t.minRatio && (s.scale = t.minRatio + 1 - (t.minRatio - s.scale + 1) ** .5), a.$imageEl.transform(`translate3d(0,0,0) scale(${s.scale})`)) }, onGestureEnd(e) { const t = this.params.zoom, s = this.zoom, { gesture: a } = s; if (!g.gestures) { if (!s.fakeGestureTouched || !s.fakeGestureMoved) return; if ("touchend" !== e.type || "touchend" === e.type && e.changedTouches.length < 2 && !C.android) return; s.fakeGestureTouched = !1, s.fakeGestureMoved = !1 } a.$imageEl && 0 !== a.$imageEl.length && (s.scale = Math.max(Math.min(s.scale, a.maxRatio), t.minRatio), a.$imageEl.transition(this.params.speed).transform(`translate3d(0,0,0) scale(${s.scale})`), s.currentScale = s.scale, s.isScaling = !1, 1 === s.scale && (a.$slideEl = void 0)) }, onTouchStart(e) { const t = this.zoom, { gesture: s, image: a } = t; s.$imageEl && 0 !== s.$imageEl.length && (a.isTouched || (C.android && e.cancelable && e.preventDefault(), a.isTouched = !0, a.touchesStart.x = "touchstart" === e.type ? e.targetTouches[0].pageX : e.pageX, a.touchesStart.y = "touchstart" === e.type ? e.targetTouches[0].pageY : e.pageY)) }, onTouchMove(e) { const t = this, s = t.zoom, { gesture: a, image: i, velocity: n } = s; if (!a.$imageEl || 0 === a.$imageEl.length) return; if (t.allowClick = !1, !i.isTouched || !a.$slideEl) return; i.isMoved || (i.width = a.$imageEl[0].offsetWidth, i.height = a.$imageEl[0].offsetHeight, i.startX = f.getTranslate(a.$imageWrapEl[0], "x") || 0, i.startY = f.getTranslate(a.$imageWrapEl[0], "y") || 0, a.slideWidth = a.$slideEl[0].offsetWidth, a.slideHeight = a.$slideEl[0].offsetHeight, a.$imageWrapEl.transition(0), t.rtl && (i.startX = -i.startX, i.startY = -i.startY)); const r = i.width * s.scale, l = i.height * s.scale; if (!(r < a.slideWidth && l < a.slideHeight)) { if (i.minX = Math.min(a.slideWidth / 2 - r / 2, 0), i.maxX = -i.minX, i.minY = Math.min(a.slideHeight / 2 - l / 2, 0), i.maxY = -i.minY, i.touchesCurrent.x = "touchmove" === e.type ? e.targetTouches[0].pageX : e.pageX, i.touchesCurrent.y = "touchmove" === e.type ? e.targetTouches[0].pageY : e.pageY, !i.isMoved && !s.isScaling) { if (t.isHorizontal() && (Math.floor(i.minX) === Math.floor(i.startX) && i.touchesCurrent.x < i.touchesStart.x || Math.floor(i.maxX) === Math.floor(i.startX) && i.touchesCurrent.x > i.touchesStart.x)) return void (i.isTouched = !1); if (!t.isHorizontal() && (Math.floor(i.minY) === Math.floor(i.startY) && i.touchesCurrent.y < i.touchesStart.y || Math.floor(i.maxY) === Math.floor(i.startY) && i.touchesCurrent.y > i.touchesStart.y)) return void (i.isTouched = !1) } e.cancelable && e.preventDefault(), e.stopPropagation(), i.isMoved = !0, i.currentX = i.touchesCurrent.x - i.touchesStart.x + i.startX, i.currentY = i.touchesCurrent.y - i.touchesStart.y + i.startY, i.currentX < i.minX && (i.currentX = i.minX + 1 - (i.minX - i.currentX + 1) ** .8), i.currentX > i.maxX && (i.currentX = i.maxX - 1 + (i.currentX - i.maxX + 1) ** .8), i.currentY < i.minY && (i.currentY = i.minY + 1 - (i.minY - i.currentY + 1) ** .8), i.currentY > i.maxY && (i.currentY = i.maxY - 1 + (i.currentY - i.maxY + 1) ** .8), n.prevPositionX || (n.prevPositionX = i.touchesCurrent.x), n.prevPositionY || (n.prevPositionY = i.touchesCurrent.y), n.prevTime || (n.prevTime = Date.now()), n.x = (i.touchesCurrent.x - n.prevPositionX) / (Date.now() - n.prevTime) / 2, n.y = (i.touchesCurrent.y - n.prevPositionY) / (Date.now() - n.prevTime) / 2, Math.abs(i.touchesCurrent.x - n.prevPositionX) < 2 && (n.x = 0), Math.abs(i.touchesCurrent.y - n.prevPositionY) < 2 && (n.y = 0), n.prevPositionX = i.touchesCurrent.x, n.prevPositionY = i.touchesCurrent.y, n.prevTime = Date.now(), a.$imageWrapEl.transform(`translate3d(${i.currentX}px, ${i.currentY}px,0)`) } }, onTouchEnd() { const e = this.zoom, { gesture: t, image: s, velocity: a } = e; if (!t.$imageEl || 0 === t.$imageEl.length) return; if (!s.isTouched || !s.isMoved) return s.isTouched = !1, void (s.isMoved = !1); s.isTouched = !1, s.isMoved = !1; let i = 300, n = 300; const r = a.x * i, l = s.currentX + r, o = a.y * n, d = s.currentY + o; 0 !== a.x && (i = Math.abs((l - s.currentX) / a.x)), 0 !== a.y && (n = Math.abs((d - s.currentY) / a.y)); const c = Math.max(i, n); s.currentX = l, s.currentY = d; const p = s.width * e.scale, u = s.height * e.scale; s.minX = Math.min(t.slideWidth / 2 - p / 2, 0), s.maxX = -s.minX, s.minY = Math.min(t.slideHeight / 2 - u / 2, 0), s.maxY = -s.minY, s.currentX = Math.max(Math.min(s.currentX, s.maxX), s.minX), s.currentY = Math.max(Math.min(s.currentY, s.maxY), s.minY), t.$imageWrapEl.transition(c).transform(`translate3d(${s.currentX}px, ${s.currentY}px,0)`) }, onTransitionEnd() { const e = this.zoom, { gesture: t } = e; t.$slideEl && this.previousIndex !== this.activeIndex && (t.$imageEl && t.$imageEl.transform("translate3d(0,0,0) scale(1)"), t.$imageWrapEl && t.$imageWrapEl.transform("translate3d(0,0,0)"), e.scale = 1, e.currentScale = 1, t.$slideEl = void 0, t.$imageEl = void 0, t.$imageWrapEl = void 0) }, toggle(e) { const t = this.zoom; t.scale && 1 !== t.scale ? t.out() : t.in(e) }, in(e) { const t = this, s = t.zoom, a = t.params.zoom, { gesture: i, image: n } = s; if (i.$slideEl || (t.params.virtual && t.params.virtual.enabled && t.virtual ? i.$slideEl = t.$wrapperEl.children("." + t.params.slideActiveClass) : i.$slideEl = t.slides.eq(t.activeIndex), i.$imageEl = i.$slideEl.find("img, svg, canvas, picture, .swiper-zoom-target"), i.$imageWrapEl = i.$imageEl.parent("." + a.containerClass)), !i.$imageEl || 0 === i.$imageEl.length) return; let r, l, o, d, c, p, u, h, m, f, g, v, b, y, w, x, E, S; i.$slideEl.addClass("" + a.zoomedSlideClass), void 0 === n.touchesStart.x && e ? (r = "touchend" === e.type ? e.changedTouches[0].pageX : e.pageX, l = "touchend" === e.type ? e.changedTouches[0].pageY : e.pageY) : (r = n.touchesStart.x, l = n.touchesStart.y), s.scale = i.$imageWrapEl.attr("data-swiper-zoom") || a.maxRatio, s.currentScale = i.$imageWrapEl.attr("data-swiper-zoom") || a.maxRatio, e ? (E = i.$slideEl[0].offsetWidth, S = i.$slideEl[0].offsetHeight, o = i.$slideEl.offset().left, d = i.$slideEl.offset().top, c = o + E / 2 - r, p = d + S / 2 - l, m = i.$imageEl[0].offsetWidth, f = i.$imageEl[0].offsetHeight, g = m * s.scale, v = f * s.scale, b = Math.min(E / 2 - g / 2, 0), y = Math.min(S / 2 - v / 2, 0), w = -b, x = -y, u = c * s.scale, h = p * s.scale, u < b && (u = b), u > w && (u = w), h < y && (h = y), h > x && (h = x)) : (u = 0, h = 0), i.$imageWrapEl.transition(300).transform(`translate3d(${u}px, ${h}px,0)`), i.$imageEl.transition(300).transform(`translate3d(0,0,0) scale(${s.scale})`) }, out() { const e = this, t = e.zoom, s = e.params.zoom, { gesture: a } = t; a.$slideEl || (e.params.virtual && e.params.virtual.enabled && e.virtual ? a.$slideEl = e.$wrapperEl.children("." + e.params.slideActiveClass) : a.$slideEl = e.slides.eq(e.activeIndex), a.$imageEl = a.$slideEl.find("img, svg, canvas, picture, .swiper-zoom-target"), a.$imageWrapEl = a.$imageEl.parent("." + s.containerClass)), a.$imageEl && 0 !== a.$imageEl.length && (t.scale = 1, t.currentScale = 1, a.$imageWrapEl.transition(300).transform("translate3d(0,0,0)"), a.$imageEl.transition(300).transform("translate3d(0,0,0) scale(1)"), a.$slideEl.removeClass("" + s.zoomedSlideClass), a.$slideEl = void 0) }, enable() { const e = this, t = e.zoom; if (t.enabled) return; t.enabled = !0; const s = !("touchstart" !== e.touchEvents.start || !g.passiveListener || !e.params.passiveListeners) && { passive: !0, capture: !1 }, a = !g.passiveListener || { passive: !1, capture: !0 }, i = "." + e.params.slideClass; g.gestures ? (e.$wrapperEl.on("gesturestart", i, t.onGestureStart, s), e.$wrapperEl.on("gesturechange", i, t.onGestureChange, s), e.$wrapperEl.on("gestureend", i, t.onGestureEnd, s)) : "touchstart" === e.touchEvents.start && (e.$wrapperEl.on(e.touchEvents.start, i, t.onGestureStart, s), e.$wrapperEl.on(e.touchEvents.move, i, t.onGestureChange, a), e.$wrapperEl.on(e.touchEvents.end, i, t.onGestureEnd, s), e.touchEvents.cancel && e.$wrapperEl.on(e.touchEvents.cancel, i, t.onGestureEnd, s)), e.$wrapperEl.on(e.touchEvents.move, "." + e.params.zoom.containerClass, t.onTouchMove, a) }, disable() { const e = this, t = e.zoom; if (!t.enabled) return; e.zoom.enabled = !1; const s = !("touchstart" !== e.touchEvents.start || !g.passiveListener || !e.params.passiveListeners) && { passive: !0, capture: !1 }, a = !g.passiveListener || { passive: !1, capture: !0 }, i = "." + e.params.slideClass; g.gestures ? (e.$wrapperEl.off("gesturestart", i, t.onGestureStart, s), e.$wrapperEl.off("gesturechange", i, t.onGestureChange, s), e.$wrapperEl.off("gestureend", i, t.onGestureEnd, s)) : "touchstart" === e.touchEvents.start && (e.$wrapperEl.off(e.touchEvents.start, i, t.onGestureStart, s), e.$wrapperEl.off(e.touchEvents.move, i, t.onGestureChange, a), e.$wrapperEl.off(e.touchEvents.end, i, t.onGestureEnd, s), e.touchEvents.cancel && e.$wrapperEl.off(e.touchEvents.cancel, i, t.onGestureEnd, s)), e.$wrapperEl.off(e.touchEvents.move, "." + e.params.zoom.containerClass, t.onTouchMove, a) } }; const te = { loadInSlide(e, t = !0) { const s = this, a = s.params.lazy; if (void 0 === e) return; if (0 === s.slides.length) return; const i = s.virtual && s.params.virtual.enabled ? s.$wrapperEl.children(`.${s.params.slideClass}[data-swiper-slide-index="${e}"]`) : s.slides.eq(e); let n = i.find(`.${a.elementClass}:not(.${a.loadedClass}):not(.${a.loadingClass})`); !i.hasClass(a.elementClass) || i.hasClass(a.loadedClass) || i.hasClass(a.loadingClass) || (n = n.add(i[0])), 0 !== n.length && n.each((e, n) => { const r = u(n); r.addClass(a.loadingClass); const l = r.attr("data-background"), o = r.attr("data-src"), d = r.attr("data-srcset"), c = r.attr("data-sizes"), p = r.parent("picture"); s.loadImage(r[0], o || l, d, c, !1, () => { if (null != s && s && (!s || s.params) && !s.destroyed) { if (l ? (r.css("background-image", `url("${l}")`), r.removeAttr("data-background")) : (d && (r.attr("srcset", d), r.removeAttr("data-srcset")), c && (r.attr("sizes", c), r.removeAttr("data-sizes")), p.length && p.children("source").each((e, t) => { const s = u(t); s.attr("data-srcset") && (s.attr("srcset", s.attr("data-srcset")), s.removeAttr("data-srcset")) }), o && (r.attr("src", o), r.removeAttr("data-src"))), r.addClass(a.loadedClass).removeClass(a.loadingClass), i.find("." + a.preloaderClass).remove(), s.params.loop && t) { const e = i.attr("data-swiper-slide-index"); if (i.hasClass(s.params.slideDuplicateClass)) { const t = s.$wrapperEl.children(`[data-swiper-slide-index="${e}"]:not(.${s.params.slideDuplicateClass})`); s.lazy.loadInSlide(t.index(), !1) } else { const t = s.$wrapperEl.children(`.${s.params.slideDuplicateClass}[data-swiper-slide-index="${e}"]`); s.lazy.loadInSlide(t.index(), !1) } } s.emit("lazyImageReady", i[0], r[0]), s.params.autoHeight && s.updateAutoHeight() } }), s.emit("lazyImageLoad", i[0], r[0]) }) }, load() { const e = this, { $wrapperEl: t, params: s, slides: a, activeIndex: i } = e, n = e.virtual && s.virtual.enabled, r = s.lazy; let l = s.slidesPerView; function o(e) { if (n) { if (t.children(`.${s.slideClass}[data-swiper-slide-index="${e}"]`).length) return !0 } else if (a[e]) return !0; return !1 } function d(e) { return n ? u(e).attr("data-swiper-slide-index") : u(e).index() } if ("auto" === l && (l = 0), e.lazy.initialImageLoaded || (e.lazy.initialImageLoaded = !0), e.params.watchSlidesVisibility) t.children("." + s.slideVisibleClass).each((t, s) => { const a = n ? u(s).attr("data-swiper-slide-index") : u(s).index(); e.lazy.loadInSlide(a) }); else if (l > 1) for (let t = i; t < i + l; t += 1)o(t) && e.lazy.loadInSlide(t); else e.lazy.loadInSlide(i); if (r.loadPrevNext) if (l > 1 || r.loadPrevNextAmount && r.loadPrevNextAmount > 1) { const t = r.loadPrevNextAmount, s = l, n = Math.min(i + s + Math.max(t, s), a.length), d = Math.max(i - Math.max(s, t), 0); for (let t = i + l; t < n; t += 1)o(t) && e.lazy.loadInSlide(t); for (let t = d; t < i; t += 1)o(t) && e.lazy.loadInSlide(t) } else { const a = t.children("." + s.slideNextClass); a.length > 0 && e.lazy.loadInSlide(d(a)); const i = t.children("." + s.slidePrevClass); i.length > 0 && e.lazy.loadInSlide(d(i)) } } }; const se = { LinearSpline: function (e, t) { const s = function () { let e, t, s; return (a, i) => { for (t = -1, e = a.length; e - t > 1;)s = e + t >> 1, a[s] <= i ? t = s : e = s; return e } }(); let a, i; return this.x = e, this.y = t, this.lastIndex = e.length - 1, this.interpolate = function (e) { return e ? (i = s(this.x, e), a = i - 1, (e - this.x[a]) * (this.y[i] - this.y[a]) / (this.x[i] - this.x[a]) + this.y[a]) : 0 }, this }, getInterpolateFunction(e) { const t = this; t.controller.spline || (t.controller.spline = t.params.loop ? new se.LinearSpline(t.slidesGrid, e.slidesGrid) : new se.LinearSpline(t.snapGrid, e.snapGrid)) }, setTranslate(e, t) { const s = this, a = s.controller.control; let i, n; function r(e) { const t = s.rtlTranslate ? -s.translate : s.translate; "slide" === s.params.controller.by && (s.controller.getInterpolateFunction(e), n = -s.controller.spline.interpolate(-t)), n && "container" !== s.params.controller.by || (i = (e.maxTranslate() - e.minTranslate()) / (s.maxTranslate() - s.minTranslate()), n = (t - s.minTranslate()) * i + e.minTranslate()), s.params.controller.inverse && (n = e.maxTranslate() - n), e.updateProgress(n), e.setTranslate(n, s), e.updateActiveIndex(), e.updateSlidesClasses() } if (Array.isArray(a)) for (let e = 0; e < a.length; e += 1)a[e] !== t && a[e] instanceof B && r(a[e]); else a instanceof B && t !== a && r(a) }, setTransition(e, t) { const s = this, a = s.controller.control; let i; function n(t) { t.setTransition(e, s), 0 !== e && (t.transitionStart(), t.params.autoHeight && f.nextTick(() => { t.updateAutoHeight() }), t.$wrapperEl.transitionEnd(() => { a && (t.params.loop && "slide" === s.params.controller.by && t.loopFix(), t.transitionEnd()) })) } if (Array.isArray(a)) for (i = 0; i < a.length; i += 1)a[i] !== t && a[i] instanceof B && n(a[i]); else a instanceof B && t !== a && n(a) } }; const ae = { makeElFocusable: e => (e.attr("tabIndex", "0"), e), makeElNotFocusable: e => (e.attr("tabIndex", "-1"), e), addElRole: (e, t) => (e.attr("role", t), e), addElLabel: (e, t) => (e.attr("aria-label", t), e), disableEl: e => (e.attr("aria-disabled", !0), e), enableEl: e => (e.attr("aria-disabled", !1), e), onEnterKey(e) { const t = this, s = t.params.a11y; if (13 !== e.keyCode) return; const a = u(e.target); t.navigation && t.navigation.$nextEl && a.is(t.navigation.$nextEl) && (t.isEnd && !t.params.loop || t.slideNext(), t.isEnd ? t.a11y.notify(s.lastSlideMessage) : t.a11y.notify(s.nextSlideMessage)), t.navigation && t.navigation.$prevEl && a.is(t.navigation.$prevEl) && (t.isBeginning && !t.params.loop || t.slidePrev(), t.isBeginning ? t.a11y.notify(s.firstSlideMessage) : t.a11y.notify(s.prevSlideMessage)), t.pagination && a.is("." + t.params.pagination.bulletClass) && a[0].click() }, notify(e) { const t = this.a11y.liveRegion; 0 !== t.length && (t.html(""), t.html(e)) }, updateNavigation() { const e = this; if (e.params.loop || !e.navigation) return; const { $nextEl: t, $prevEl: s } = e.navigation; s && s.length > 0 && (e.isBeginning ? (e.a11y.disableEl(s), e.a11y.makeElNotFocusable(s)) : (e.a11y.enableEl(s), e.a11y.makeElFocusable(s))), t && t.length > 0 && (e.isEnd ? (e.a11y.disableEl(t), e.a11y.makeElNotFocusable(t)) : (e.a11y.enableEl(t), e.a11y.makeElFocusable(t))) }, updatePagination() { const e = this, t = e.params.a11y; e.pagination && e.params.pagination.clickable && e.pagination.bullets && e.pagination.bullets.length && e.pagination.bullets.each((s, a) => { const i = u(a); e.a11y.makeElFocusable(i), e.a11y.addElRole(i, "button"), e.a11y.addElLabel(i, t.paginationBulletMessage.replace(/\{\{index\}\}/, i.index() + 1)) }) }, init() { const e = this; e.$el.append(e.a11y.liveRegion); const t = e.params.a11y; let s, a; e.navigation && e.navigation.$nextEl && (s = e.navigation.$nextEl), e.navigation && e.navigation.$prevEl && (a = e.navigation.$prevEl), s && (e.a11y.makeElFocusable(s), e.a11y.addElRole(s, "button"), e.a11y.addElLabel(s, t.nextSlideMessage), s.on("keydown", e.a11y.onEnterKey)), a && (e.a11y.makeElFocusable(a), e.a11y.addElRole(a, "button"), e.a11y.addElLabel(a, t.prevSlideMessage), a.on("keydown", e.a11y.onEnterKey)), e.pagination && e.params.pagination.clickable && e.pagination.bullets && e.pagination.bullets.length && e.pagination.$el.on("keydown", "." + e.params.pagination.bulletClass, e.a11y.onEnterKey) }, destroy() { const e = this; let t, s; e.a11y.liveRegion && e.a11y.liveRegion.length > 0 && e.a11y.liveRegion.remove(), e.navigation && e.navigation.$nextEl && (t = e.navigation.$nextEl), e.navigation && e.navigation.$prevEl && (s = e.navigation.$prevEl), t && t.off("keydown", e.a11y.onEnterKey), s && s.off("keydown", e.a11y.onEnterKey), e.pagination && e.params.pagination.clickable && e.pagination.bullets && e.pagination.bullets.length && e.pagination.$el.off("keydown", "." + e.params.pagination.bulletClass, e.a11y.onEnterKey) } }; const ie = { init() { const e = this; if (!e.params.history) return; if (!c.history || !c.history.pushState) return e.params.history.enabled = !1, void (e.params.hashNavigation.enabled = !0); const t = e.history; t.initialized = !0, t.paths = ie.getPathValues(), (t.paths.key || t.paths.value) && (t.scrollToSlide(0, t.paths.value, e.params.runCallbacksOnInit), e.params.history.replaceState || c.addEventListener("popstate", e.history.setHistoryPopState)) }, destroy() { const e = this; e.params.history.replaceState || c.removeEventListener("popstate", e.history.setHistoryPopState) }, setHistoryPopState() { this.history.paths = ie.getPathValues(), this.history.scrollToSlide(this.params.speed, this.history.paths.value, !1) }, getPathValues() { const e = c.location.pathname.slice(1).split("/").filter(e => "" !== e), t = e.length; return { key: e[t - 2], value: e[t - 1] } }, setHistory(e, t) { if (!this.history.initialized || !this.params.history.enabled) return; const s = this.slides.eq(t); let a = ie.slugify(s.attr("data-history")); c.location.pathname.includes(e) || (a = `${e}/${a}`); const i = c.history.state; i && i.value === a || (this.params.history.replaceState ? c.history.replaceState({ value: a }, null, a) : c.history.pushState({ value: a }, null, a)) }, slugify: e => e.toString().replace(/\s+/g, "-").replace(/[^\w-]+/g, "").replace(/--+/g, "-").replace(/^-+/, "").replace(/-+$/, ""), scrollToSlide(e, t, s) { const a = this; if (t) for (let i = 0, n = a.slides.length; i < n; i += 1) { const n = a.slides.eq(i); if (ie.slugify(n.attr("data-history")) === t && !n.hasClass(a.params.slideDuplicateClass)) { const t = n.index(); a.slideTo(t, e, s) } } else a.slideTo(0, e, s) } }; const ne = { onHashCange() { const e = this; e.emit("hashChange"); const t = o.location.hash.replace("#", ""); if (t !== e.slides.eq(e.activeIndex).attr("data-hash")) { const s = e.$wrapperEl.children(`.${e.params.slideClass}[data-hash="${t}"]`).index(); if (void 0 === s) return; e.slideTo(s) } }, setHash() { const e = this; if (e.hashNavigation.initialized && e.params.hashNavigation.enabled) if (e.params.hashNavigation.replaceState && c.history && c.history.replaceState) c.history.replaceState(null, null, "#" + e.slides.eq(e.activeIndex).attr("data-hash") || ""), e.emit("hashSet"); else { const t = e.slides.eq(e.activeIndex), s = t.attr("data-hash") || t.attr("data-history"); o.location.hash = s || "", e.emit("hashSet") } }, init() { const e = this; if (!e.params.hashNavigation.enabled || e.params.history && e.params.history.enabled) return; e.hashNavigation.initialized = !0; const t = o.location.hash.replace("#", ""); if (t) { const s = 0; for (let a = 0, i = e.slides.length; a < i; a += 1) { const i = e.slides.eq(a); if ((i.attr("data-hash") || i.attr("data-history")) === t && !i.hasClass(e.params.slideDuplicateClass)) { const t = i.index(); e.slideTo(t, s, e.params.runCallbacksOnInit, !0) } } } e.params.hashNavigation.watchState && u(c).on("hashchange", e.hashNavigation.onHashCange) }, destroy() { const e = this; e.params.hashNavigation.watchState && u(c).off("hashchange", e.hashNavigation.onHashCange) } }; const re = { run() { const e = this, t = e.slides.eq(e.activeIndex); let s = e.params.autoplay.delay; t.attr("data-swiper-autoplay") && (s = t.attr("data-swiper-autoplay") || e.params.autoplay.delay), clearTimeout(e.autoplay.timeout), e.autoplay.timeout = f.nextTick(() => { e.params.autoplay.reverseDirection ? e.params.loop ? (e.loopFix(), e.slidePrev(e.params.speed, !0, !0), e.emit("autoplay")) : e.isBeginning ? e.params.autoplay.stopOnLastSlide ? e.autoplay.stop() : (e.slideTo(e.slides.length - 1, e.params.speed, !0, !0), e.emit("autoplay")) : (e.slidePrev(e.params.speed, !0, !0), e.emit("autoplay")) : e.params.loop ? (e.loopFix(), e.slideNext(e.params.speed, !0, !0), e.emit("autoplay")) : e.isEnd ? e.params.autoplay.stopOnLastSlide ? e.autoplay.stop() : (e.slideTo(0, e.params.speed, !0, !0), e.emit("autoplay")) : (e.slideNext(e.params.speed, !0, !0), e.emit("autoplay")), e.params.cssMode && e.autoplay.running && e.autoplay.run() }, s) }, start() { return void 0 === this.autoplay.timeout && (!this.autoplay.running && (this.autoplay.running = !0, this.emit("autoplayStart"), this.autoplay.run(), !0)) }, stop() { const e = this; return !!e.autoplay.running && (void 0 !== e.autoplay.timeout && (e.autoplay.timeout && (clearTimeout(e.autoplay.timeout), e.autoplay.timeout = void 0), e.autoplay.running = !1, e.emit("autoplayStop"), !0)) }, pause(e) { const t = this; t.autoplay.running && (t.autoplay.paused || (t.autoplay.timeout && clearTimeout(t.autoplay.timeout), t.autoplay.paused = !0, 0 !== e && t.params.autoplay.waitForTransition ? (t.$wrapperEl[0].addEventListener("transitionend", t.autoplay.onTransitionEnd), t.$wrapperEl[0].addEventListener("webkitTransitionEnd", t.autoplay.onTransitionEnd)) : (t.autoplay.paused = !1, t.autoplay.run()))) } }; const le = { setTranslate() { const e = this, { slides: t } = e; for (let s = 0; s < t.length; s += 1) { const t = e.slides.eq(s); let a = -t[0].swiperSlideOffset; e.params.virtualTranslate || (a -= e.translate); let i = 0; e.isHorizontal() || (i = a, a = 0); const n = e.params.fadeEffect.crossFade ? Math.max(1 - Math.abs(t[0].progress), 0) : 1 + Math.min(Math.max(t[0].progress, -1), 0); t.css({ opacity: n }).transform(`translate3d(${a}px, ${i}px, 0px)`) } }, setTransition(e) { const t = this, { slides: s, $wrapperEl: a } = t; if (s.transition(e), t.params.virtualTranslate && 0 !== e) { let e = !1; s.transitionEnd(() => { if (e) return; if (!t || t.destroyed) return; e = !0, t.animating = !1; const s = ["webkitTransitionEnd", "transitionend"]; for (let e = 0; e < s.length; e += 1)a.trigger(s[e]) }) } } }; const oe = { setTranslate() { const { $el: e, $wrapperEl: t, slides: s, width: a, height: i, rtlTranslate: n, size: r } = this, l = this.params.cubeEffect, o = this.isHorizontal(), d = this.virtual && this.params.virtual.enabled; let c, p = 0; l.shadow && (o ? (c = t.find(".swiper-cube-shadow"), 0 === c.length && (c = u('<div class="swiper-cube-shadow"></div>'), t.append(c)), c.css({ height: a + "px" })) : (c = e.find(".swiper-cube-shadow"), 0 === c.length && (c = u('<div class="swiper-cube-shadow"></div>'), e.append(c)))); for (let e = 0; e < s.length; e += 1) { const t = s.eq(e); let a = e; d && (a = parseInt(t.attr("data-swiper-slide-index"), 10)); let i = 90 * a, c = Math.floor(i / 360); n && (i = -i, c = Math.floor(-i / 360)); const h = Math.max(Math.min(t[0].progress, 1), -1); let m = 0, f = 0, g = 0; a % 4 == 0 ? (m = 4 * -c * r, g = 0) : (a - 1) % 4 == 0 ? (m = 0, g = 4 * -c * r) : (a - 2) % 4 == 0 ? (m = r + 4 * c * r, g = r) : (a - 3) % 4 == 0 && (m = -r, g = 3 * r + 4 * r * c), n && (m = -m), o || (f = m, m = 0); const v = `rotateX(${o ? 0 : -i}deg) rotateY(${o ? i : 0}deg) translate3d(${m}px, ${f}px, ${g}px)`; if (h <= 1 && h > -1 && (p = 90 * a + 90 * h, n && (p = 90 * -a - 90 * h)), t.transform(v), l.slideShadows) { let e = o ? t.find(".swiper-slide-shadow-left") : t.find(".swiper-slide-shadow-top"), s = o ? t.find(".swiper-slide-shadow-right") : t.find(".swiper-slide-shadow-bottom"); 0 === e.length && (e = u(`<div class="swiper-slide-shadow-${o ? "left" : "top"}"></div>`), t.append(e)), 0 === s.length && (s = u(`<div class="swiper-slide-shadow-${o ? "right" : "bottom"}"></div>`), t.append(s)), e.length && (e[0].style.opacity = Math.max(-h, 0)), s.length && (s[0].style.opacity = Math.max(h, 0)) } } if (t.css({ "-webkit-transform-origin": `50% 50% -${r / 2}px`, "-moz-transform-origin": `50% 50% -${r / 2}px`, "-ms-transform-origin": `50% 50% -${r / 2}px`, "transform-origin": `50% 50% -${r / 2}px` }), l.shadow) if (o) c.transform(`translate3d(0px, ${a / 2 + l.shadowOffset}px, ${-a / 2}px) rotateX(90deg) rotateZ(0deg) scale(${l.shadowScale})`); else { const e = Math.abs(p) - 90 * Math.floor(Math.abs(p) / 90), t = 1.5 - (Math.sin(2 * e * Math.PI / 360) / 2 + Math.cos(2 * e * Math.PI / 360) / 2), s = l.shadowScale, a = l.shadowScale / t, n = l.shadowOffset; c.transform(`scale3d(${s}, 1, ${a}) translate3d(0px, ${i / 2 + n}px, ${-i / 2 / a}px) rotateX(-90deg)`) } const h = q.isSafari || q.isWebView ? -r / 2 : 0; t.transform(`translate3d(0px,0,${h}px) rotateX(${this.isHorizontal() ? 0 : p}deg) rotateY(${this.isHorizontal() ? -p : 0}deg)`) }, setTransition(e) { const { $el: t, slides: s } = this; s.transition(e).find(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").transition(e), this.params.cubeEffect.shadow && !this.isHorizontal() && t.find(".swiper-cube-shadow").transition(e) } }; const de = { setTranslate() { const e = this, { slides: t, rtlTranslate: s } = e; for (let a = 0; a < t.length; a += 1) { const i = t.eq(a); let n = i[0].progress; e.params.flipEffect.limitRotation && (n = Math.max(Math.min(i[0].progress, 1), -1)); let r = -180 * n, l = 0, o = -i[0].swiperSlideOffset, d = 0; if (e.isHorizontal() ? s && (r = -r) : (d = o, o = 0, l = -r, r = 0), i[0].style.zIndex = -Math.abs(Math.round(n)) + t.length, e.params.flipEffect.slideShadows) { let t = e.isHorizontal() ? i.find(".swiper-slide-shadow-left") : i.find(".swiper-slide-shadow-top"), s = e.isHorizontal() ? i.find(".swiper-slide-shadow-right") : i.find(".swiper-slide-shadow-bottom"); 0 === t.length && (t = u(`<div class="swiper-slide-shadow-${e.isHorizontal() ? "left" : "top"}"></div>`), i.append(t)), 0 === s.length && (s = u(`<div class="swiper-slide-shadow-${e.isHorizontal() ? "right" : "bottom"}"></div>`), i.append(s)), t.length && (t[0].style.opacity = Math.max(-n, 0)), s.length && (s[0].style.opacity = Math.max(n, 0)) } i.transform(`translate3d(${o}px, ${d}px, 0px) rotateX(${l}deg) rotateY(${r}deg)`) } }, setTransition(e) { const t = this, { slides: s, activeIndex: a, $wrapperEl: i } = t; if (s.transition(e).find(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").transition(e), t.params.virtualTranslate && 0 !== e) { let e = !1; s.eq(a).transitionEnd((function () { if (e) return; if (!t || t.destroyed) return; e = !0, t.animating = !1; const s = ["webkitTransitionEnd", "transitionend"]; for (let e = 0; e < s.length; e += 1)i.trigger(s[e]) })) } } }; const ce = { setTranslate() { const { width: e, height: t, slides: s, $wrapperEl: a, slidesSizesGrid: i } = this, n = this.params.coverflowEffect, r = this.isHorizontal(), l = this.translate, o = r ? e / 2 - l : t / 2 - l, d = r ? n.rotate : -n.rotate, c = n.depth; for (let e = 0, t = s.length; e < t; e += 1) { const t = s.eq(e), a = i[e], l = (o - t[0].swiperSlideOffset - a / 2) / a * n.modifier; let p = r ? d * l : 0, h = r ? 0 : d * l, m = -c * Math.abs(l), f = n.stretch; "string" == typeof f && -1 !== f.indexOf("%") && (f = parseFloat(n.stretch) / 100 * a); let g = r ? 0 : f * l, v = r ? f * l : 0, b = 1 - (1 - n.scale) * Math.abs(l); Math.abs(v) < .001 && (v = 0), Math.abs(g) < .001 && (g = 0), Math.abs(m) < .001 && (m = 0), Math.abs(p) < .001 && (p = 0), Math.abs(h) < .001 && (h = 0), Math.abs(b) < .001 && (b = 0); const y = `translate3d(${v}px,${g}px,${m}px)  rotateX(${h}deg) rotateY(${p}deg) scale(${b})`; if (t.transform(y), t[0].style.zIndex = 1 - Math.abs(Math.round(l)), n.slideShadows) { let e = r ? t.find(".swiper-slide-shadow-left") : t.find(".swiper-slide-shadow-top"), s = r ? t.find(".swiper-slide-shadow-right") : t.find(".swiper-slide-shadow-bottom"); 0 === e.length && (e = u(`<div class="swiper-slide-shadow-${r ? "left" : "top"}"></div>`), t.append(e)), 0 === s.length && (s = u(`<div class="swiper-slide-shadow-${r ? "right" : "bottom"}"></div>`), t.append(s)), e.length && (e[0].style.opacity = l > 0 ? l : 0), s.length && (s[0].style.opacity = -l > 0 ? -l : 0) } } if (g.pointerEvents || g.prefixedPointerEvents) { a[0].style.perspectiveOrigin = o + "px 50%" } }, setTransition(e) { this.slides.transition(e).find(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").transition(e) } }; const pe = { init() { const e = this, { thumbs: t } = e.params, s = e.constructor; t.swiper instanceof s ? (e.thumbs.swiper = t.swiper, f.extend(e.thumbs.swiper.originalParams, { watchSlidesProgress: !0, slideToClickedSlide: !1 }), f.extend(e.thumbs.swiper.params, { watchSlidesProgress: !0, slideToClickedSlide: !1 })) : f.isObject(t.swiper) && (e.thumbs.swiper = new s(f.extend({}, t.swiper, { watchSlidesVisibility: !0, watchSlidesProgress: !0, slideToClickedSlide: !1 })), e.thumbs.swiperCreated = !0), e.thumbs.swiper.$el.addClass(e.params.thumbs.thumbsContainerClass), e.thumbs.swiper.on("tap", e.thumbs.onThumbClick) }, onThumbClick() { const e = this, t = e.thumbs.swiper; if (!t) return; const s = t.clickedIndex, a = t.clickedSlide; if (a && u(a).hasClass(e.params.thumbs.slideThumbActiveClass)) return; if (null == s) return; let i; if (i = t.params.loop ? parseInt(u(t.clickedSlide).attr("data-swiper-slide-index"), 10) : s, e.params.loop) { let t = e.activeIndex; e.slides.eq(t).hasClass(e.params.slideDuplicateClass) && (e.loopFix(), e._clientLeft = e.$wrapperEl[0].clientLeft, t = e.activeIndex); const s = e.slides.eq(t).prevAll(`[data-swiper-slide-index="${i}"]`).eq(0).index(), a = e.slides.eq(t).nextAll(`[data-swiper-slide-index="${i}"]`).eq(0).index(); i = void 0 === s ? a : void 0 === a ? s : a - t < t - s ? a : s } e.slideTo(i) }, update(e) { const t = this, s = t.thumbs.swiper; if (!s) return; const a = "auto" === s.params.slidesPerView ? s.slidesPerViewDynamic() : s.params.slidesPerView, i = t.params.thumbs.autoScrollOffset, n = i && !s.params.loop; if (t.realIndex !== s.realIndex || n) { let r, l, o = s.activeIndex; if (s.params.loop) { s.slides.eq(o).hasClass(s.params.slideDuplicateClass) && (s.loopFix(), s._clientLeft = s.$wrapperEl[0].clientLeft, o = s.activeIndex); const e = s.slides.eq(o).prevAll(`[data-swiper-slide-index="${t.realIndex}"]`).eq(0).index(), a = s.slides.eq(o).nextAll(`[data-swiper-slide-index="${t.realIndex}"]`).eq(0).index(); r = void 0 === e ? a : void 0 === a ? e : a - o == o - e ? o : a - o < o - e ? a : e, l = t.activeIndex > t.previousIndex ? "next" : "prev" } else r = t.realIndex, l = r > t.previousIndex ? "next" : "prev"; n && (r += "next" === l ? i : -1 * i), s.visibleSlidesIndexes && s.visibleSlidesIndexes.indexOf(r) < 0 && (s.params.centeredSlides ? r = r > o ? r - Math.floor(a / 2) + 1 : r + Math.floor(a / 2) - 1 : r > o && (r = r - a + 1), s.slideTo(r, e ? 0 : void 0)) } let r = 1; const l = t.params.thumbs.slideThumbActiveClass; if (t.params.slidesPerView > 1 && !t.params.centeredSlides && (r = t.params.slidesPerView), t.params.thumbs.multipleActiveThumbs || (r = 1), r = Math.floor(r), s.slides.removeClass(l), s.params.loop || s.params.virtual && s.params.virtual.enabled) for (let e = 0; e < r; e += 1)s.$wrapperEl.children(`[data-swiper-slide-index="${t.realIndex + e}"]`).addClass(l); else for (let e = 0; e < r; e += 1)s.slides.eq(t.realIndex + e).addClass(l) } }; const ue = [H, N, V, X, F, R, j, { name: "mousewheel", params: { mousewheel: { enabled: !1, releaseOnEdges: !1, invert: !1, forceToAxis: !1, sensitivity: 1, eventsTarged: "container" } }, create() { f.extend(this, { mousewheel: { enabled: !1, enable: K.enable.bind(this), disable: K.disable.bind(this), handle: K.handle.bind(this), handleMouseEnter: K.handleMouseEnter.bind(this), handleMouseLeave: K.handleMouseLeave.bind(this), animateSlider: K.animateSlider.bind(this), releaseScroll: K.releaseScroll.bind(this), lastScrollTime: f.now(), lastEventBeforeSnap: void 0, recentWheelEvents: [] } }) }, on: { init() { const e = this; !e.params.mousewheel.enabled && e.params.cssMode && e.mousewheel.disable(), e.params.mousewheel.enabled && e.mousewheel.enable() }, destroy() { const e = this; e.params.cssMode && e.mousewheel.enable(), e.mousewheel.enabled && e.mousewheel.disable() } } }, { name: "navigation", params: { navigation: { nextEl: null, prevEl: null, hideOnClick: !1, disabledClass: "swiper-button-disabled", hiddenClass: "swiper-button-hidden", lockClass: "swiper-button-lock" } }, create() { f.extend(this, { navigation: { init: U.init.bind(this), update: U.update.bind(this), destroy: U.destroy.bind(this), onNextClick: U.onNextClick.bind(this), onPrevClick: U.onPrevClick.bind(this) } }) }, on: { init() { this.navigation.init(), this.navigation.update() }, toEdge() { this.navigation.update() }, fromEdge() { this.navigation.update() }, destroy() { this.navigation.destroy() }, click(e) { const t = this, { $nextEl: s, $prevEl: a } = t.navigation; if (t.params.navigation.hideOnClick && !u(e.target).is(a) && !u(e.target).is(s)) { let e; s ? e = s.hasClass(t.params.navigation.hiddenClass) : a && (e = a.hasClass(t.params.navigation.hiddenClass)), !0 === e ? t.emit("navigationShow", t) : t.emit("navigationHide", t), s && s.toggleClass(t.params.navigation.hiddenClass), a && a.toggleClass(t.params.navigation.hiddenClass) } } } }, { name: "pagination", params: { pagination: { el: null, bulletElement: "span", clickable: !1, hideOnClick: !1, renderBullet: null, renderProgressbar: null, renderFraction: null, renderCustom: null, progressbarOpposite: !1, type: "bullets", dynamicBullets: !1, dynamicMainBullets: 1, formatFractionCurrent: e => e, formatFractionTotal: e => e, bulletClass: "swiper-pagination-bullet", bulletActiveClass: "swiper-pagination-bullet-active", modifierClass: "swiper-pagination-", currentClass: "swiper-pagination-current", totalClass: "swiper-pagination-total", hiddenClass: "swiper-pagination-hidden", progressbarFillClass: "swiper-pagination-progressbar-fill", progressbarOppositeClass: "swiper-pagination-progressbar-opposite", clickableClass: "swiper-pagination-clickable", lockClass: "swiper-pagination-lock" } }, create() { f.extend(this, { pagination: { init: Z.init.bind(this), render: Z.render.bind(this), update: Z.update.bind(this), destroy: Z.destroy.bind(this), dynamicBulletIndex: 0 } }) }, on: { init() { this.pagination.init(), this.pagination.render(), this.pagination.update() }, activeIndexChange() { const e = this; (e.params.loop || void 0 === e.snapIndex) && e.pagination.update() }, snapIndexChange() { const e = this; e.params.loop || e.pagination.update() }, slidesLengthChange() { const e = this; e.params.loop && (e.pagination.render(), e.pagination.update()) }, snapGridLengthChange() { const e = this; e.params.loop || (e.pagination.render(), e.pagination.update()) }, destroy() { this.pagination.destroy() }, click(e) { const t = this; if (t.params.pagination.el && t.params.pagination.hideOnClick && t.pagination.$el.length > 0 && !u(e.target).hasClass(t.params.pagination.bulletClass)) { !0 === t.pagination.$el.hasClass(t.params.pagination.hiddenClass) ? t.emit("paginationShow", t) : t.emit("paginationHide", t), t.pagination.$el.toggleClass(t.params.pagination.hiddenClass) } } } }, { name: "scrollbar", params: { scrollbar: { el: null, dragSize: "auto", hide: !1, draggable: !1, snapOnRelease: !0, lockClass: "swiper-scrollbar-lock", dragClass: "swiper-scrollbar-drag" } }, create() { f.extend(this, { scrollbar: { init: Q.init.bind(this), destroy: Q.destroy.bind(this), updateSize: Q.updateSize.bind(this), setTranslate: Q.setTranslate.bind(this), setTransition: Q.setTransition.bind(this), enableDraggable: Q.enableDraggable.bind(this), disableDraggable: Q.disableDraggable.bind(this), setDragPosition: Q.setDragPosition.bind(this), getPointerPosition: Q.getPointerPosition.bind(this), onDragStart: Q.onDragStart.bind(this), onDragMove: Q.onDragMove.bind(this), onDragEnd: Q.onDragEnd.bind(this), isTouched: !1, timeout: null, dragTimeout: null } }) }, on: { init() { this.scrollbar.init(), this.scrollbar.updateSize(), this.scrollbar.setTranslate() }, update() { this.scrollbar.updateSize() }, resize() { this.scrollbar.updateSize() }, observerUpdate() { this.scrollbar.updateSize() }, setTranslate() { this.scrollbar.setTranslate() }, setTransition(e) { this.scrollbar.setTransition(e) }, destroy() { this.scrollbar.destroy() } } }, { name: "parallax", params: { parallax: { enabled: !1 } }, create() { f.extend(this, { parallax: { setTransform: J.setTransform.bind(this), setTranslate: J.setTranslate.bind(this), setTransition: J.setTransition.bind(this) } }) }, on: { beforeInit() { this.params.parallax.enabled && (this.params.watchSlidesProgress = !0, this.originalParams.watchSlidesProgress = !0) }, init() { this.params.parallax.enabled && this.parallax.setTranslate() }, setTranslate() { this.params.parallax.enabled && this.parallax.setTranslate() }, setTransition(e) { this.params.parallax.enabled && this.parallax.setTransition(e) } } }, { name: "zoom", params: { zoom: { enabled: !1, maxRatio: 3, minRatio: 1, toggle: !0, containerClass: "swiper-zoom-container", zoomedSlideClass: "swiper-slide-zoomed" } }, create() { const e = this, t = { enabled: !1, scale: 1, currentScale: 1, isScaling: !1, gesture: { $slideEl: void 0, slideWidth: void 0, slideHeight: void 0, $imageEl: void 0, $imageWrapEl: void 0, maxRatio: 3 }, image: { isTouched: void 0, isMoved: void 0, currentX: void 0, currentY: void 0, minX: void 0, minY: void 0, maxX: void 0, maxY: void 0, width: void 0, height: void 0, startX: void 0, startY: void 0, touchesStart: {}, touchesCurrent: {} }, velocity: { x: void 0, y: void 0, prevPositionX: void 0, prevPositionY: void 0, prevTime: void 0 } }; "onGestureStart onGestureChange onGestureEnd onTouchStart onTouchMove onTouchEnd onTransitionEnd toggle enable disable in out".split(" ").forEach(s => { t[s] = ee[s].bind(e) }), f.extend(e, { zoom: t }); let s = 1; Object.defineProperty(e.zoom, "scale", { get: () => s, set(t) { if (s !== t) { const s = e.zoom.gesture.$imageEl ? e.zoom.gesture.$imageEl[0] : void 0, a = e.zoom.gesture.$slideEl ? e.zoom.gesture.$slideEl[0] : void 0; e.emit("zoomChange", t, s, a) } s = t } }) }, on: { init() { const e = this; e.params.zoom.enabled && e.zoom.enable() }, destroy() { this.zoom.disable() }, touchStart(e) { this.zoom.enabled && this.zoom.onTouchStart(e) }, touchEnd(e) { this.zoom.enabled && this.zoom.onTouchEnd(e) }, doubleTap(e) { const t = this; t.params.zoom.enabled && t.zoom.enabled && t.params.zoom.toggle && t.zoom.toggle(e) }, transitionEnd() { const e = this; e.zoom.enabled && e.params.zoom.enabled && e.zoom.onTransitionEnd() }, slideChange() { const e = this; e.zoom.enabled && e.params.zoom.enabled && e.params.cssMode && e.zoom.onTransitionEnd() } } }, { name: "lazy", params: { lazy: { enabled: !1, loadPrevNext: !1, loadPrevNextAmount: 1, loadOnTransitionStart: !1, elementClass: "swiper-lazy", loadingClass: "swiper-lazy-loading", loadedClass: "swiper-lazy-loaded", preloaderClass: "swiper-lazy-preloader" } }, create() { f.extend(this, { lazy: { initialImageLoaded: !1, load: te.load.bind(this), loadInSlide: te.loadInSlide.bind(this) } }) }, on: { beforeInit() { const e = this; e.params.lazy.enabled && e.params.preloadImages && (e.params.preloadImages = !1) }, init() { const e = this; e.params.lazy.enabled && !e.params.loop && 0 === e.params.initialSlide && e.lazy.load() }, scroll() { const e = this; e.params.freeMode && !e.params.freeModeSticky && e.lazy.load() }, resize() { const e = this; e.params.lazy.enabled && e.lazy.load() }, scrollbarDragMove() { const e = this; e.params.lazy.enabled && e.lazy.load() }, transitionStart() { const e = this; e.params.lazy.enabled && (e.params.lazy.loadOnTransitionStart || !e.params.lazy.loadOnTransitionStart && !e.lazy.initialImageLoaded) && e.lazy.load() }, transitionEnd() { const e = this; e.params.lazy.enabled && !e.params.lazy.loadOnTransitionStart && e.lazy.load() }, slideChange() { const e = this; e.params.lazy.enabled && e.params.cssMode && e.lazy.load() } } }, { name: "controller", params: { controller: { control: void 0, inverse: !1, by: "slide" } }, create() { f.extend(this, { controller: { control: this.params.controller.control, getInterpolateFunction: se.getInterpolateFunction.bind(this), setTranslate: se.setTranslate.bind(this), setTransition: se.setTransition.bind(this) } }) }, on: { update() { const e = this; e.controller.control && e.controller.spline && (e.controller.spline = void 0, delete e.controller.spline) }, resize() { const e = this; e.controller.control && e.controller.spline && (e.controller.spline = void 0, delete e.controller.spline) }, observerUpdate() { const e = this; e.controller.control && e.controller.spline && (e.controller.spline = void 0, delete e.controller.spline) }, setTranslate(e, t) { this.controller.control && this.controller.setTranslate(e, t) }, setTransition(e, t) { this.controller.control && this.controller.setTransition(e, t) } } }, { name: "a11y", params: { a11y: { enabled: !0, notificationClass: "swiper-notification", prevSlideMessage: "Previous slide", nextSlideMessage: "Next slide", firstSlideMessage: "This is the first slide", lastSlideMessage: "This is the last slide", paginationBulletMessage: "Go to slide {{index}}" } }, create() { const e = this; f.extend(e, { a11y: { liveRegion: u(`<span class="${e.params.a11y.notificationClass}" aria-live="assertive" aria-atomic="true"></span>`) } }), Object.keys(ae).forEach(t => { e.a11y[t] = ae[t].bind(e) }) }, on: { init() { this.params.a11y.enabled && (this.a11y.init(), this.a11y.updateNavigation()) }, toEdge() { this.params.a11y.enabled && this.a11y.updateNavigation() }, fromEdge() { this.params.a11y.enabled && this.a11y.updateNavigation() }, paginationUpdate() { this.params.a11y.enabled && this.a11y.updatePagination() }, destroy() { this.params.a11y.enabled && this.a11y.destroy() } } }, { name: "history", params: { history: { enabled: !1, replaceState: !1, key: "slides" } }, create() { f.extend(this, { history: { init: ie.init.bind(this), setHistory: ie.setHistory.bind(this), setHistoryPopState: ie.setHistoryPopState.bind(this), scrollToSlide: ie.scrollToSlide.bind(this), destroy: ie.destroy.bind(this) } }) }, on: { init() { const e = this; e.params.history.enabled && e.history.init() }, destroy() { const e = this; e.params.history.enabled && e.history.destroy() }, transitionEnd() { const e = this; e.history.initialized && e.history.setHistory(e.params.history.key, e.activeIndex) }, slideChange() { const e = this; e.history.initialized && e.params.cssMode && e.history.setHistory(e.params.history.key, e.activeIndex) } } }, { name: "hash-navigation", params: { hashNavigation: { enabled: !1, replaceState: !1, watchState: !1 } }, create() { f.extend(this, { hashNavigation: { initialized: !1, init: ne.init.bind(this), destroy: ne.destroy.bind(this), setHash: ne.setHash.bind(this), onHashCange: ne.onHashCange.bind(this) } }) }, on: { init() { const e = this; e.params.hashNavigation.enabled && e.hashNavigation.init() }, destroy() { const e = this; e.params.hashNavigation.enabled && e.hashNavigation.destroy() }, transitionEnd() { const e = this; e.hashNavigation.initialized && e.hashNavigation.setHash() }, slideChange() { const e = this; e.hashNavigation.initialized && e.params.cssMode && e.hashNavigation.setHash() } } }, { name: "autoplay", params: { autoplay: { enabled: !1, delay: 3e3, waitForTransition: !0, disableOnInteraction: !0, stopOnLastSlide: !1, reverseDirection: !1 } }, create() { const e = this; f.extend(e, { autoplay: { running: !1, paused: !1, run: re.run.bind(e), start: re.start.bind(e), stop: re.stop.bind(e), pause: re.pause.bind(e), onVisibilityChange() { "hidden" === document.visibilityState && e.autoplay.running && e.autoplay.pause(), "visible" === document.visibilityState && e.autoplay.paused && (e.autoplay.run(), e.autoplay.paused = !1) }, onTransitionEnd(t) { e && !e.destroyed && e.$wrapperEl && t.target === this && (e.$wrapperEl[0].removeEventListener("transitionend", e.autoplay.onTransitionEnd), e.$wrapperEl[0].removeEventListener("webkitTransitionEnd", e.autoplay.onTransitionEnd), e.autoplay.paused = !1, e.autoplay.running ? e.autoplay.run() : e.autoplay.stop()) } } }) }, on: { init() { const e = this; e.params.autoplay.enabled && (e.autoplay.start(), document.addEventListener("visibilitychange", e.autoplay.onVisibilityChange)) }, beforeTransitionStart(e, t) { const s = this; s.autoplay.running && (t || !s.params.autoplay.disableOnInteraction ? s.autoplay.pause(e) : s.autoplay.stop()) }, sliderFirstMove() { const e = this; e.autoplay.running && (e.params.autoplay.disableOnInteraction ? e.autoplay.stop() : e.autoplay.pause()) }, touchEnd() { const e = this; e.params.cssMode && e.autoplay.paused && !e.params.autoplay.disableOnInteraction && e.autoplay.run() }, destroy() { const e = this; e.autoplay.running && e.autoplay.stop(), document.removeEventListener("visibilitychange", e.autoplay.onVisibilityChange) } } }, { name: "effect-fade", params: { fadeEffect: { crossFade: !1 } }, create() { f.extend(this, { fadeEffect: { setTranslate: le.setTranslate.bind(this), setTransition: le.setTransition.bind(this) } }) }, on: { beforeInit() { if ("fade" !== this.params.effect) return; this.classNames.push(this.params.containerModifierClass + "fade"); const e = { slidesPerView: 1, slidesPerColumn: 1, slidesPerGroup: 1, watchSlidesProgress: !0, spaceBetween: 0, virtualTranslate: !0 }; f.extend(this.params, e), f.extend(this.originalParams, e) }, setTranslate() { "fade" === this.params.effect && this.fadeEffect.setTranslate() }, setTransition(e) { "fade" === this.params.effect && this.fadeEffect.setTransition(e) } } }, { name: "effect-cube", params: { cubeEffect: { slideShadows: !0, shadow: !0, shadowOffset: 20, shadowScale: .94 } }, create() { f.extend(this, { cubeEffect: { setTranslate: oe.setTranslate.bind(this), setTransition: oe.setTransition.bind(this) } }) }, on: { beforeInit() { if ("cube" !== this.params.effect) return; this.classNames.push(this.params.containerModifierClass + "cube"), this.classNames.push(this.params.containerModifierClass + "3d"); const e = { slidesPerView: 1, slidesPerColumn: 1, slidesPerGroup: 1, watchSlidesProgress: !0, resistanceRatio: 0, spaceBetween: 0, centeredSlides: !1, virtualTranslate: !0 }; f.extend(this.params, e), f.extend(this.originalParams, e) }, setTranslate() { "cube" === this.params.effect && this.cubeEffect.setTranslate() }, setTransition(e) { "cube" === this.params.effect && this.cubeEffect.setTransition(e) } } }, { name: "effect-flip", params: { flipEffect: { slideShadows: !0, limitRotation: !0 } }, create() { f.extend(this, { flipEffect: { setTranslate: de.setTranslate.bind(this), setTransition: de.setTransition.bind(this) } }) }, on: { beforeInit() { if ("flip" !== this.params.effect) return; this.classNames.push(this.params.containerModifierClass + "flip"), this.classNames.push(this.params.containerModifierClass + "3d"); const e = { slidesPerView: 1, slidesPerColumn: 1, slidesPerGroup: 1, watchSlidesProgress: !0, spaceBetween: 0, virtualTranslate: !0 }; f.extend(this.params, e), f.extend(this.originalParams, e) }, setTranslate() { "flip" === this.params.effect && this.flipEffect.setTranslate() }, setTransition(e) { "flip" === this.params.effect && this.flipEffect.setTransition(e) } } }, { name: "effect-coverflow", params: { coverflowEffect: { rotate: 50, stretch: 0, depth: 100, scale: 1, modifier: 1, slideShadows: !0 } }, create() { f.extend(this, { coverflowEffect: { setTranslate: ce.setTranslate.bind(this), setTransition: ce.setTransition.bind(this) } }) }, on: { beforeInit() { "coverflow" === this.params.effect && (this.classNames.push(this.params.containerModifierClass + "coverflow"), this.classNames.push(this.params.containerModifierClass + "3d"), this.params.watchSlidesProgress = !0, this.originalParams.watchSlidesProgress = !0) }, setTranslate() { "coverflow" === this.params.effect && this.coverflowEffect.setTranslate() }, setTransition(e) { "coverflow" === this.params.effect && this.coverflowEffect.setTransition(e) } } }, { name: "thumbs", params: { thumbs: { swiper: null, multipleActiveThumbs: !0, autoScrollOffset: 0, slideThumbActiveClass: "swiper-slide-thumb-active", thumbsContainerClass: "swiper-container-thumbs" } }, create() { f.extend(this, { thumbs: { swiper: null, init: pe.init.bind(this), update: pe.update.bind(this), onThumbClick: pe.onThumbClick.bind(this) } }) }, on: { beforeInit() { const { thumbs: e } = this.params; e && e.swiper && (this.thumbs.init(), this.thumbs.update(!0)) }, slideChange() { this.thumbs.swiper && this.thumbs.update() }, update() { this.thumbs.swiper && this.thumbs.update() }, resize() { this.thumbs.swiper && this.thumbs.update() }, observerUpdate() { this.thumbs.swiper && this.thumbs.update() }, setTransition(e) { const t = this.thumbs.swiper; t && t.setTransition(e) }, beforeDestroy() { const e = this.thumbs.swiper; e && this.thumbs.swiperCreated && e && e.destroy() } } }]; void 0 === B.use && (B.use = B.Class.use, B.installModule = B.Class.installModule), B.use(ue); var he = B; function me(e) { return (me = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) { return typeof e } : function (e) { return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e })(e) } function fe(e, t) { for (var s = 0; s < t.length; s++) { var a = t[s]; a.enumerable = a.enumerable || !1, a.configurable = !0, "value" in a && (a.writable = !0), Object.defineProperty(e, (i = a.key, n = void 0, n = function (e, t) { if ("object" !== me(e) || null === e) return e; var s = e[Symbol.toPrimitive]; if (void 0 !== s) { var a = s.call(e, t || "default"); if ("object" !== me(a)) return a; throw new TypeError("@@toPrimitive must return a primitive value.") } return ("string" === t ? String : Number)(e) }(i, "string"), "symbol" === me(n) ? n : String(n)), a) } var i, n } var ge = function () { function e() { var t = this; !function (e, t) { if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function") }(this, e), this.tab = !!document.querySelector(".tab") && document.querySelectorAll(".tab"), this.alert_red = !!document.querySelector(".alert_red") && document.querySelectorAll(".alert_red"), this.organisLists = !!document.querySelector(".organisations-listing") && document.querySelectorAll(".organisations-listing"), this.people_profiles = !!document.querySelector(".people_profiles") && document.querySelectorAll(".people_profiles"), this.business_slider = !!document.querySelector(".business-slider") && document.querySelectorAll(".business-slider"), this.navs = !!document.querySelector(".nav_blue") && document.querySelectorAll(".nav_blue"), !this.tab || this.tab.forEach((function (e) { return t.s_tab(e) })), !this.alert_red || this.alert_red.forEach((function (e) { return t.s_alertRed(e) })), !this.organisLists || this.organisLists.forEach((function (e) { return t.s_orgLists(e) })), !this.people_profiles || this.people_profiles.forEach((function (e) { return t.s_profiles(e) })), !this.business_slider || this.business_slider.forEach((function (e) { return t.s_business(e) })), !this.navs || this.navs.forEach((function (e) { return t.sNavs(e) })) } var t, s, a; return t = e, (s = [{ key: "sNavs", value: function (e) { e.querySelector(".nav_blue__btn").addEventListener("click", (function (t) { t.target.classList.toggle("active"), e.querySelector("ul").classList.toggle("active") })) } }, { key: "s_business", value: function (e) { new he(e.querySelector(".mySwiper"), { slidesPerView: 1, spaceBetween: 10, navigation: { nextEl: ".swiper-button-next", prevEl: ".swiper-button-prev" }, breakpoints: { 480: { slidesPerView: 2, spaceBetween: 20 }, 767: { slidesPerView: 3, spaceBetween: 30 }, 991: { slidesPerView: 4, spaceBetween: 30 } } }), e.querySelectorAll(".business-slider__item").forEach((function (e) { e.querySelector("a").addEventListener("click", (function (t) { t.preventDefault(), e.classList.add("active") })) })) } }, { key: "s_profiles", value: function (e) { e.querySelectorAll(".item").forEach((function (t) { t.querySelector("a.show").addEventListener("click", (function (s) { s.preventDefault(), t.classList.contains("active") ? (t.classList.remove("active"), e.querySelector('.content[data-index="'.concat(t.dataset.index, '"]')).classList.remove("active")) : (e.querySelectorAll(".item").forEach((function (e) { return e.classList.remove("active") })), t.classList.add("active"), e.querySelectorAll(".content").forEach((function (e) { return e.classList.remove("active") })), e.querySelector('.content[data-index="'.concat(t.dataset.index, '"]')).classList.add("active")) })) })) } }, { key: "s_orgLists", value: function (e) { var t = e.querySelector(".gallery"), s = e.querySelector(".player"); !t || t.addEventListener("click", (function (a) { a.preventDefault(), [t, s, e.querySelector(".slider"), e.querySelector(".video")].forEach((function (e) { e && e.classList.remove("active") })), e.querySelector(".slider").classList.add("active"), t.classList.add("active") })), !s || s.addEventListener("click", (function (a) { a.preventDefault(), [t, s, e.querySelector(".slider"), e.querySelector(".video")].forEach((function (e) { e && e.classList.remove("active") })), e.querySelector(".video").classList.add("active"), s.classList.add("active") })) } }, { key: "s_alertRed", value: function (e) { e.querySelector(".close").addEventListener("click", (function (t) { t.preventDefault(), e.classList.add("hidden") })) } }, { key: "s_tab", value: function (e) { var t = e.querySelectorAll(".nav-link"), s = e.querySelectorAll(".tab__content__item"); t.forEach((function (a) { return a.addEventListener("click", (function (a) { a.preventDefault(), t.forEach((function (e) { return e.classList.remove("active") })), s.forEach((function (e) { return e.classList.remove("active") })), a.target.classList.add("active"), e.querySelector('.tab__content__item[data-item="'.concat(a.target.dataset.item, '"]')).classList.add("active") })) })) } }]) && fe(t.prototype, s), a && fe(t, a), Object.defineProperty(t, "prototype", { writable: !1 }), e }(); new n, new ge }, function (e, t) { }]);
	//# sourceMappingURL=main.min.js.map
}
catch (e) {
	console.log(e);
}

import $ from "jquery";
import "../scss/main.scss";
import 'slick-carousel/slick/slick.min';
const accordionHeadings = document.querySelectorAll('.accordion-heading');
// Hides * once users starts typing 
$(document).ready(function () {
	$('input[type="text"]').on("input", function () {
		var fieldName = $(this).attr('name');
		var requiredField = $('.required-field[data-field-name="' + fieldName + '"]');
		requiredField.hide();
	});

	// Initially disabled the next button on the supporting evidence page
	$('#nextButton').prop('disabled', true);

	// Checks if user has uploaded a file 
	$('input[type="file"]').on('change', function () {
		var anyFileSelected = false;
		$('input[type="file"]').each(function () {
			if ($(this).get(0).files.length > 0) {
				anyFileSelected = true;
				return false;
			}
		});

		// Enable or disable the Next button based on whether a file is selected
		$('#nextButton').prop('disabled', !anyFileSelected);
	});
	
	//Accordion controls

	accordionHeadings.forEach((heading) => {
		heading.addEventListener('click', () => {
			const content = heading.nextElementSibling;
			heading.classList.toggle('active');
			content.style.display = content.style.display === 'block' ? 'none' : 'block';
		});
	});
});

// Code to ensure the ApplyDiscount() gets hit
document.addEventListener('DOMContentLoaded', function () {
	var updateButton = document.getElementById("updateButton");

	updateButton.addEventListener("click", function (e) {
		e.preventDefault();
		var form = document.getElementById("discountForm");
		form.submit();
	});
});

// This disables the verify button on account creation to stop multiple clicks

var verifyButton = document.getElementById("accountCreationVerifyButton");
var form = document.getElementById("memberRegistration");
function handleButtonClick() {
	verifyButton.disabled = true;
	if (form) {
		form.submit();
	}
	setTimeout(function () {
		verifyButton.disabled = false;
	}, 8000);
}

if (verifyButton) {
	verifyButton.addEventListener('click', handleButtonClick);
}

// Clears user session and cookies when they logout
function clearCookiesAndSessionStorage() {
	var cookies = document.cookie.split(";");
	for (var i = 0; i < cookies.length; i++) {
		var cookie = cookies[i];
		var eqPos = cookie.indexOf("=");
		var name = eqPos > -1 ? cookie.slice(0, eqPos) : cookie;
		document.cookie = name + "=;expires=Thu, 01 Jan 1970 00:00:00 GMT;path=/";
	}
	sessionStorage.clear();
}

// On logout cookies and session are cleared
var logoutButton = document.getElementById("logoutButton");

if (logoutButton) {
	logoutButton.addEventListener("click", function () {
		clearCookiesAndSessionStorage();
	});
}

document.addEventListener('DOMContentLoaded', function (event) {
	let forms = document.getElementsByClassName("hot-cache");
	if (forms === undefined) {
		return;
	}
	let form = forms[0];
	let inputs = form.getElementsByTagName("input");
	for (let i = 0; i < inputs.length; i++) {
		let el = inputs[i];
		let cachedVal = localStorage.getItem(el.attributes["name"].value);

		if (cachedVal !== null) {
			if (el.type === "checkbox") {
				el.checked = cachedVal;
			}
			else {
				el.value = cachedVal;
			}
		}
	}
});

cacheInput = function (e) {
	if (e.type === "checkbox") {
		localStorage.setItem(e.attributes["name"].value, e.checked);
	}
	else {
		localStorage.setItem(e.attributes["name"].value, e.value);
	}
};

clearCache = function () {
	localStorage.clear()
};

valueMatch = function (elem, otherFieldId) {
	var otherValue = $('#' + otherFieldId).val();
	var thisVal = elem.value;
	if (thisVal !== otherValue) {
		elem.dataset["valRequired"] = otherFieldId + "Email must match";
		elem.setCustomValidity(otherFieldId + " must match");
	}
	else {
		elem.setCustomValidity("");
	}
};

selectCourseBooking = function (value) {

	$('#ForContactOnly').val(value)
	if (value) {
		$('#CourseBookingForm').submit();
	}
	else {
		$('.training-part[data-part="2"]').show();
		$('.training-part[data-part="1"]').hide();
	}
}

$(".js-testimonial-slider").slick({
	'fade': true,
	'nextArrow': "<button type='button' class='slick-next'></button>",
	'prevArrow': "<button type='button' class='slick-prev'></button>"
});

$(".js-banner-slider").slick();

$(".js-pay-type").click(function () {
	var id = $(this).data("id")

	if (id == "card") {
		$('.js-card').show();
		$('.js-invoice').hide();
		$('.js-directDebit').hide();
		this.disabled = true
		$('*[data-id="invoice"]').removeAttr('disabled');
		$('*[data-id="directDebit"]').removeAttr('disabled');
		$("#tAndc").prop('required', false);
		$('#cardholder-name').prop('required', true);
		$('#cardNumber').prop('required', true);
		$('#cardExpiry').prop('required', true);
		$('#cardCVC').prop('required', true);
		$('#flexCheckDefault').prop('required', true);
		$('#PayByInvoice').val(false);
		$('#PayByCard').val(true);
		$('#PayByDirectDebit').val(false);
	}
	else if (id == "invoice") {
		$('.js-card').hide();
		$('.js-invoice').show();
		$('.js-directDebit').hide();
		this.disabled = true
		$('.js-pay-type[data-id="card"]').removeAttr('disabled');
		$('.js-pay-type[data-id="directDebit"]').removeAttr('disabled');
		$("#tAndc").prop('required', true);
		$('#cardholder-name').prop('required', false);
		$('#cardNumber').prop('required', false);
		$('#cardExpiry').prop('required', false);
		$('#cardCVC').prop('required', false);
		$('#flexCheckDefault').prop('required', false);
		$('#PayByInvoice').val(true);
		$('#PayByCard').val(false);
		$('#PayByDirectDebit').val(false);
	}
	else if (id == "directDebit") {
		$('.js-card').hide();
		$('.js-invoice').hide();
		$('.js-directDebit').show();
		this.disabled = true
		$('.js-pay-type[data-id="card"]').removeAttr('disabled');
		$('.js-pay-type[data-id="invoice"]').removeAttr('disabled');
		$("#tAndc").prop('required', true);
		$('#cardholder-name').prop('required', false);
		$('#cardNumber').prop('required', false);
		$('#cardExpiry').prop('required', false);
		$('#cardCVC').prop('required', false);
		$('#flexCheckDefault').prop('required', false);
		$('#PayByInvoice').val(false);
		$('#PayByCard').val(false);
		$('#PayByDirectDebit').val(true);
	}
});

$("#UseBillingDetails").click(function () {
	var container = $("#billingDetails");
	container.toggle();

	if (container.is(":visible")) {
		$('#BillingFirstName').prop('required', true);
		$('#BillingLastName').prop('required', true);
		$('#BillingAddressLine1').prop('required', true);
		$('#BillingPostcode').prop('required', true);
	}
	else {
		$('#BillingFirstName').prop('required', false);
		$('#BillingLastName').prop('required', false);
		$('#BillingAddressLine1').prop('required', false);
		$('#BillingPostcode').prop('required', false);
	}
});

$('#dd-option').click(function () {
	$('.js-dd-application-select').show();
});

$('.js-dd-application-select').on("change", function () {
	if (this.value !== undefined && this.value != null && this.value !== "") {
		$('#PayViaDD').show();
		$('#PayViaDD').prop("disabled", false);
	}
	else
	{
		$('#PayViaDD').prop("disabled", true);
		$('#PayViaDD').hide();
	}
});


